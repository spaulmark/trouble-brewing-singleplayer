<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clocktower Simulator</title>
    <style>
      /* --- Basic Styling --- */
      :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --primary-color: #a02c2c;
        --card-bg: #2c2c2c;
        --border-color: #444;
        --townsfolk-color: #2e86c1;
        --outsider-color: #85c1e9;
        --minion-color: #e74c3c;
        --demon-color: #c0392b;
      }

      #kill-mode-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        font-size: 1em;
        font-weight: bold;
        background-color: #333;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        z-index: 1000;
        transition: background-color 0.3s, color 0.3s;
      }

      /* Style for the button when kill mode is ON */
      body.kill-mode-active #kill-mode-toggle {
        background-color: var(--primary-color);
        color: white;
        border-color: #c0392b;
      }

      /* Smooth transition for the body background color change */
      body {
        transition: background-color 0.4s ease;
      }

      /* Style for the body when kill mode is ON */
      body.kill-mode-active {
        background-color: #2a1a1a; /* Subtle dark red background */
      }

      .container.kill-mode-active {
        background-color: rgb(70, 40, 40);
        transition: background-color 0.3s, color 0.3s;
      }

      /* Change cursor to crosshair on tokens ONLY when in kill mode */
      body.kill-mode-active .player-token {
        cursor: crosshair;
      }

      .player-token {
        /* Add this line to the existing .player-token rule */
        position: relative;
      }

      .speech-bubble {
        pointer-events: none;
        position: absolute;
        bottom: 100%; /* Position it directly above the token */
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 10px; /* Space between bubble and token */

        background-color: #e0e0e0;
        color: #1a1a1a;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: bold;
        text-align: center;
        width: 140px; /* Give it a fixed width to handle longer text */
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);

        /* Hide it by default until we add content */
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      /* The little triangle pointing down */
      .speech-bubble::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 8px;
        border-style: solid;
        border-color: #e0e0e0 transparent transparent transparent;
      }

      /* A simple class to make the bubble visible */
      .speech-bubble.visible {
        visibility: visible;
        opacity: 1;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s, color 0.3s;
      }

      h1,
      h2,
      h3 {
        text-align: center;
        color: var(--primary-color);
        text-transform: uppercase;
        letter-spacing: 2px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 10px;
        margin-bottom: 20px;
      }

      /* --- Controls --- */
      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 30px;
      }

      .controls label {
        font-size: 1.1em;
        font-weight: bold;
      }

      #player-count,
      #generate-btn {
        padding: 10px 15px;
        font-size: 1em;
        border-radius: 5px;
        border: 1px solid var(--border-color);
        background-color: #333;
        color: var(--text-color);
        cursor: pointer;
      }

      #generate-btn {
        background-color: var(--primary-color);
        color: white;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }

      #generate-btn:hover {
        background-color: #c0392b;
      }

      /* --- Script Display --- */
      .script-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
        visibility: hidden;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li {
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
      }
      li strong {
        display: inline;
        font-size: 1.1em;
        color: #fff;
      }
      li .ability {
        display: block;
        margin-top: 5px;
      }
      .drunk-marker {
        font-weight: bold;
        font-style: italic;
        color: var(--outsider-color);
        margin-left: 8px;
      }

      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      .circle-container {
        position: relative;
        width: 700px; /* Adjust size as needed */
        height: 700px;
        margin: 100px auto 40px;
        border: 2px dashed var(--border-color);
        border-radius: 50%;
      }

      .player-token {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 120px;
        height: 60px;
        margin: -30px 0 0 -60px; /* (height/2) and (width/2) */

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;

        border: 3px solid white;
        border-radius: 8px;
        background-color: var(--card-bg);
        font-size: 0.9em;

        transition: opacity 0.3s ease;
        user-select: none; /* Prevent text selection on click */
      }

      /* Style for dead players */
      .player-token.dead {
        opacity: 0.4;
      }
      .player-token.dead strong,
      .player-token.dead span {
        text-decoration: line-through;
      }

      .player-token strong {
        font-size: 1.1em;
        color: var(--text-color);
      }
      .player-token span {
        font-weight: bold;
      }

      /* Color coding the tokens by role type */
      .player-token.townsfolk {
        border-color: var(--townsfolk-color);
      }
      .player-token.townsfolk span {
        color: var(--townsfolk-color);
      }

      .player-token.outsider {
        border-color: var(--outsider-color);
      }
      .player-token.outsider span {
        color: var(--outsider-color);
      }

      .player-token.minion {
        border-color: var(--minion-color);
      }
      .player-token.minion span {
        color: var(--minion-color);
      }

      .player-token.demon {
        border-color: var(--demon-color);
      }
      .player-token.demon span {
        color: var(--demon-color);
      }
    </style>
  </head>
  <body>
    <div class="container" id="container">
      <div class="controls">
        <label for="player-count">Select Player Count:</label>
        <select id="player-count">
          <option value="7">7 Players</option>
          <option value="8">8 Players</option>
          <option value="9">9 Players</option>
          <option value="10">10 Players</option>
          <option value="11">11 Players</option>
          <option value="12" selected>12 Players</option>
          <option value="13">13 Players</option>
          <option value="14">14 Players</option>
          <option value="15">15 Players</option>
        </select>
        <button id="generate-btn">New Game</button>
      </div>
      <div id="player-assignments">
        <div class="circle-container" id="circle-container">
          <!-- Player tokens will be generated here by -->
        </div>
        <button id="kill-mode-toggle">Execute Mode: OFF</button>
      </div>
    </div>

    <script>
      // --- DATA ---
      const characters = {
        townsfolk: [
          {
            name: "Washerwoman",
            ability:
              "You start knowing that 1 of 2 players is a particular Townsfolk.",
            type: "townsfolk",
          },
          {
            name: "Librarian",
            ability:
              "You start knowing that 1 of 2 players is a particular Outsider.",
            type: "townsfolk",
          },
          {
            name: "Investigator",
            ability:
              "You start knowing that 1 of 2 players is a particular Minion.",
            type: "townsfolk",
          },
          {
            name: "Chef",
            ability:
              "You start knowing how many pairs of evil players there are.",
            type: "townsfolk",
          },
          {
            name: "Empath",
            ability:
              "Each night, you learn how many of your 2 alive neighbours are evil.",
            type: "townsfolk",
          },
          {
            name: "Fortune Teller",
            ability:
              "Each night, choose 2 players: you learn if either is a Demon.",
            type: "townsfolk",
          },
          {
            name: "Undertaker",
            ability:
              "Each night*, you learn which character died by execution today.",
            type: "townsfolk",
          },
          {
            name: "Monk",
            ability:
              "Each night*, choose a player (not yourself): they are safe from the Demon tonight.",
            type: "townsfolk",
          },
          {
            name: "Ravenkeeper",
            ability:
              "If you die at night, you are woken to choose a player: you learn their character.",
            type: "townsfolk",
          },
          {
            name: "Virgin",
            ability:
              "The 1st time you are nominated, if the nominator is a Townsfolk, they are executed immediately.",
            type: "townsfolk",
          },
          {
            name: "Slayer",
            ability:
              "Once per game, during the day, publicly choose a player: if they are the Demon, they die.",
            type: "townsfolk",
          },
          {
            name: "Soldier",
            ability: "You are safe from the Demon.",
            type: "townsfolk",
          },
          {
            name: "Mayor",
            ability:
              "If only 3 players live & no execution occurs, your team wins.",
            type: "townsfolk",
          },
        ],
        outsiders: [
          {
            name: "Butler",
            ability:
              "Each night, choose a player (not yourself): tomorrow, you may only vote if they are voting too.",
            type: "outsider",
          },
          {
            name: "Drunk",
            ability:
              "You do not know you are the Drunk. You think you are a Townsfolk character, but you are not.",
            type: "outsider",
          },
          {
            name: "Recluse",
            ability:
              "You might register as evil & as a Minion or Demon, even if dead.",
            type: "outsider",
          },
          {
            name: "Saint",
            ability: "If you die by execution, your team loses.",
            type: "outsider",
          },
        ],
        minions: [
          {
            name: "Poisoner",
            ability:
              "Each night, choose a player: they are poisoned tonight and tomorrow day.",
            type: "minion",
          },
          {
            name: "Spy",
            ability:
              "Each night, you see the Grimoire. You might register as good & as a Townsfolk or Outsider, even if dead.",
            type: "minion",
          },
          {
            name: "Scarlet Woman",
            ability:
              "If there are 5 or more players alive & the Demon dies, you become the Demon.",
            type: "minion",
          },
          {
            name: "Baron",
            ability: "There are extra Outsiders in play. [+2 Outsiders]",
            type: "minion",
          },
        ],
        demons: [
          {
            name: "Imp",
            ability:
              "Each night*, choose a player: they die. If you kill yourself this way, a Minion becomes the Imp.",
            type: "demon",
          },
        ],
      };

      const playerCounts = {
        7: { townsfolk: 5, outsiders: 0, minions: 1, demons: 1 },
        8: { townsfolk: 5, outsiders: 1, minions: 1, demons: 1 },
        9: { townsfolk: 5, outsiders: 2, minions: 1, demons: 1 },
        10: { townsfolk: 7, outsiders: 0, minions: 2, demons: 1 },
        11: { townsfolk: 7, outsiders: 1, minions: 2, demons: 1 },
        12: { townsfolk: 7, outsiders: 2, minions: 2, demons: 1 },
        13: { townsfolk: 9, outsiders: 0, minions: 3, demons: 1 },
        14: { townsfolk: 9, outsiders: 1, minions: 3, demons: 1 },
        15: { townsfolk: 9, outsiders: 2, minions: 3, demons: 1 },
      };

      const playerNames = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
      ];

      const playerCountSelect = document.getElementById("player-count");
      const generateBtn = document.getElementById("generate-btn");
      const circleContainer = document.getElementById("circle-container");
      const container = document.getElementById("container");

      const killModeToggleBtn = document.getElementById("kill-mode-toggle");
      let isKillMode = false;
      let currentPhase = "day";
      let canExecutePlayer = true;

      killModeToggleBtn.addEventListener("click", () => {
        // Toggle the state
        isKillMode = !isKillMode;

        // Toggle the class on the body to trigger CSS changes
        document.body.classList.toggle("kill-mode-active", isKillMode);
        container.classList.toggle("kill-mode-active", isKillMode);

        // Update the button text to reflect the current mode
        if (isKillMode) {
          killModeToggleBtn.textContent = "Execute Mode: ON";
        } else {
          killModeToggleBtn.textContent = "Execute Mode: OFF";
        }
      });

      // --- LOGIC ---
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function getRandomItems(array, numItems) {
        const shuffled = shuffleArray([...array]);
        return shuffled.slice(0, numItems);
      }

      function executePlayer(playerToken) {
        // Guard 1: Check if an execution is currently allowed
        if (!canExecutePlayer) {
          console.log("An execution has already happened this day.");
          return; // Stop the function
        }

        // Guard 2: Don't execute already dead players
        if (playerToken.classList.contains("dead")) {
          return;
        }

        // --- If guards pass, proceed with execution ---
        console.log("Executing player...");
        playerToken.classList.add("dead");

        // Disable further executions for this day/phase
        canExecutePlayer = false;

        // You could add a visual cue here, like updating a game log
        // For now, let's log it and simulate moving to the night phase
        console.log("The day ends. Night falls...");
        currentPhase = "night";

        // Here you would call other functions that happen at night
        othernights();

        // Optional: Add a delay before you can proceed to the next day
        // to simulate the night phase passing.
        setTimeout(() => {
          console.log("Night is over. A new day begins.");
          currentPhase = "day";
          canExecutePlayer = true;
          // TODO: text in the center of the circle saying what phase it is and stuff
        }, 1500); // 1.5 second night
      }

      // player class?
      /*

      role template:

      fortune teller: {

      default_choicebubble: "Who should I pick tonight?"
      }



      {
        seat: 0
        role: "role"           // ie. drunk
        isEvil: true/false     // only 2 alignments in botc
        appears_as: "my bluff" // ie. fortune teller
        my_info_text: "A/B yes, C/D no"

      }
      
      */

      function night1() {
        // poisoner
        // washerwoman
        // librarian
        // investigator
        // chef
        // empath
        // fortune teller
      }

      function othernights() {
        // poisoner
        // monk
        // scarlet woman...? idk
        // imp
        // ravenkeeper
        // undertaker
        // empath
        // ft
      }

      function generateAndDisplayScript() {
        const playerCount = parseInt(playerCountSelect.value, 10);
        let counts = { ...playerCounts[playerCount] };

        // --- SCRIPT GENERATION ---
        const selectedMinions = getRandomItems(
          characters.minions,
          counts.minions
        );
        const isBaronInPlay = selectedMinions.some(
          (minion) => minion.name === "Baron"
        );
        if (isBaronInPlay) {
          counts.townsfolk -= 2;
          counts.outsiders += 2;
        }

        const initialOutsiders = getRandomItems(
          characters.outsiders,
          counts.outsiders
        );
        let finalOutsiders = [...initialOutsiders];
        let isDrunkInPlay = false;

        const drunkIndex = initialOutsiders.findIndex(
          (o) => o.name === "Drunk"
        );
        // deletes the drunk token from outsiders
        if (drunkIndex > -1) {
          isDrunkInPlay = true;
          finalOutsiders.splice(drunkIndex, 1);
        }

        const shuffledTownsfolk = shuffleArray([...characters.townsfolk]);
        let selectedTownsfolk = shuffledTownsfolk.slice(0, counts.townsfolk);
        let drunksRolePlaceholder = null;
        if (isDrunkInPlay) {
          const drunksRole = shuffledTownsfolk[counts.townsfolk];
          if (drunksRole) {
            console.log(drunksRole);
            drunksRolePlaceholder = { ...drunksRole, isDrunkPlaceholder: true };
            selectedTownsfolk.push(drunksRolePlaceholder);
          }
        }

        const selectedDemons = getRandomItems(characters.demons, counts.demons);

        const allTokensForAssignment = [
          ...selectedTownsfolk,
          ...finalOutsiders,
          ...selectedMinions,
          ...selectedDemons,
        ];
        const shuffledTokens = shuffleArray(allTokensForAssignment);
        const currentPlayers = shuffleArray(playerNames.slice(0, playerCount));

        displayPlayerCircle(shuffledTokens, currentPlayers);
      }

      function displayPlayerCircle(roles, names) {
        circleContainer.innerHTML = "";
        const playerCount = names.length;
        const radius = circleContainer.offsetWidth / 2 - 70; // 70 is a magic number for spacing

        for (let i = 0; i < playerCount; i++) {
          const angle = (i / playerCount) * 360;
          const angleRad = angle * (Math.PI / 180);

          const x = radius * Math.cos(angleRad);
          const y = radius * Math.sin(angleRad);

          const role = roles[i];
          const playerName = names[i];

          const tokenEl = document.createElement("div");
          tokenEl.className = `player-token ${role.type}`;

          // The transform places the element around the circle. The final rotate(-angle) keeps the text upright.
          tokenEl.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg) translate(60px) rotate(-${angle}deg)`;

          tokenEl.innerHTML = `
  <div class="speech-bubble visible">Hello</div>
  <strong>${playerName}</strong>
  <span>${role.name}</span>
`;
          // Add a click listener to toggle the 'dead' class on the token.
          // This allows you to mark players as executed.
          tokenEl.addEventListener("click", () => {
            if (isKillMode) {
              executePlayer(tokenEl);
            }
            // TODO: If kill mode is off, clicking does nothing. (for now)
          });

          circleContainer.appendChild(tokenEl);
        }
      }

      generateBtn.addEventListener("click", generateAndDisplayScript);
      document.addEventListener("DOMContentLoaded", generateAndDisplayScript);
    </script>
  </body>
</html>
