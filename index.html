<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Single Player Trouble Brewing</title>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --primary-color: #a02c2c;
        --card-bg: #2c2c2c;
        --border-color: #444;
        --townsfolk-color: #2e86c1;
        --outsider-color: #85c1e9;
        --minion-color: #e74c3c;
        --demon-color: #c0392b;
      }
      #center-action-btn {
        position: absolute;
        top: 65%; /* Position it below the DAY/NIGHT text */
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20; /* Make sure it's on top */
        padding: 10px 20px;
        font-size: 1.1em;
        font-weight: bold;
        min-width: 160px;
        text-align: center;
        background-color: #555;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;

        /* For the fade-in/out effect */
        visibility: hidden;
        opacity: 0;
      }

      #center-action-btn:hover {
        background-color: #666;
        border-color: #777;
      }

      /* A class to make the button visible */
      #center-action-btn.visible {
        visibility: visible;
        opacity: 1;
      }
      /* container for the two mode buttons to keep them aligned */
      #mode-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 12px;
        z-index: 1000;
        align-items: center;
      }

      #kill-mode-toggle {
        /* no fixed positioning here; contained inside #mode-controls */
        padding: 12px 20px;
        font-size: 1em;
        font-weight: bold;
        background-color: #333;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        z-index: 1000;
        transition: background-color 0.3s, color 0.3s;
      }

      /* responsive: stack controls on small screens */
      @media (max-width: 420px) {
        #mode-controls {
          right: 12px;
          bottom: 12px;
          flex-direction: column-reverse;
          gap: 8px;
        }
        #mode-controls button {
          min-width: 120px;
        }
      }

      body.action-mode-active {
        background-color: #11202a;
      }

      .container.action-mode-active {
        background-color: rgb(35, 60, 75);
      }

      /* helpful cursor change to indicate action-mode selection */
      body.action-mode-active .player-token {
        cursor: pointer;
      }

      /* When in action mode, allow cursor pointer even for dead players */
      body.action-mode-active .player-token.dead:hover {
        cursor: pointer;
      }

      body.kill-mode-active #kill-mode-toggle {
        background-color: var(--primary-color);
        color: white;
        border-color: #c0392b;
      }

      body {
        transition: background-color 0.4s ease;
      }

      body.kill-mode-active {
        background-color: #2a1a1a;
      }

      .container.kill-mode-active {
        background-color: rgb(70, 40, 40);
        transition: background-color 0.3s, color 0.3s;
      }

      /* Change cursor to crosshair on tokens ONLY when in kill mode */
      body.kill-mode-active .player-token {
        cursor: crosshair;
      }

      .player-token {
        position: relative;
      }

      .speech-bubble {
        pointer-events: none;
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 10px;

        background-color: #e0e0e0;
        color: #1a1a1a;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        width: 140px;

        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .speech-bubble::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 8px;
        border-style: solid;
        border-color: #e0e0e0 transparent transparent transparent;
      }

      .speech-bubble.visible {
        visibility: visible;
        opacity: 1;
      }
      /* --- Action-ready token styling (unspent actions) --- */
      @keyframes actionPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(45, 170, 255, 0.25);
          filter: drop-shadow(0 0 0 rgba(45, 170, 255, 0));
        }
        50% {
          box-shadow: 0 0 18px 8px rgba(45, 170, 255, 0.08);
          filter: drop-shadow(0 6px 16px rgba(45, 170, 255, 0.12));
        }
        100% {
          box-shadow: 0 0 0 0 rgba(45, 170, 255, 0.25);
          filter: drop-shadow(0 0 0 rgba(45, 170, 255, 0));
        }
      }

      .player-token.action-ready {
        animation: actionPulse 2.2s infinite ease-in-out;
        border-color: rgba(45, 170, 255, 0.9);
        box-shadow: 0 0 18px rgba(45, 170, 255, 0.35);
        transform-origin: center center;
        z-index: 50; /* float above others visually */
      }

      /* Small badge in the top-right to indicate an available action */
      .player-token.action-ready::after {
        content: "‚ö°";
        position: absolute;
        top: -6px;
        right: -6px;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        border-radius: 50%;
        background: linear-gradient(135deg, #bfefff, #6fd3ff);
        color: #012233;
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 4px 10px rgba(10, 90, 140, 0.25);
      }
      /* Fortune Teller uses a different badge (?) instead of the lightning bolt */
      .player-token.action-ready[data-role="Fortune Teller"]::after {
        content: "‚ùì";
        font-size: 12px;
        background: linear-gradient(135deg, #fff5b1, #ffe07a);
        color: #332200;
        border-color: rgba(255, 255, 255, 0.9);
      }
      /* Monk uses a different badge (?) instead of the lightning bolt */
      .player-token.action-ready[data-role="Monk"]::after {
        content: "‚ùì";
        font-size: 12px;
        background: linear-gradient(135deg, #fff5b1, #ffe07a);
        color: #332200;
        border-color: rgba(255, 255, 255, 0.9);
      }
      /* Ravenkeeper uses a different badge (?) instead of the lightning bolt */
      .player-token.action-ready[data-role="Ravenkeeper"]::after {
        content: "‚ùì";
        font-size: 12px;
        background: linear-gradient(135deg, #fff5b1, #ffe07a);
        color: #332200;
        border-color: rgba(255, 255, 255, 0.9);
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s, color 0.3s;
      }

      h1,
      h2,
      h3 {
        text-align: center;
        color: var(--primary-color);
        text-transform: uppercase;
        letter-spacing: 2px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 10px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 30px;
      }

      .controls label {
        font-size: 1.1em;
        font-weight: bold;
      }

      #player-count,
      #generate-btn {
        padding: 10px 15px;
        font-size: 1em;
        border-radius: 5px;
        border: 1px solid var(--border-color);
        background-color: #333;
        color: var(--text-color);
        cursor: pointer;
      }

      #generate-btn {
        background-color: var(--primary-color);
        color: white;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }

      #generate-btn:hover {
        background-color: #c0392b;
      }

      .script-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
        visibility: hidden;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li {
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
      }
      li strong {
        display: inline;
        font-size: 1.1em;
        color: #fff;
      }
      li .ability {
        display: block;
        margin-top: 5px;
      }
      .drunk-marker {
        font-weight: bold;
        font-style: italic;
        color: var(--outsider-color);
        margin-left: 8px;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      #phase-display {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        user-select: none;

        font-size: 7em;
        font-weight: bold;
        color: rgba(224, 224, 224, 0.1);
        text-transform: uppercase;
        letter-spacing: 5px;
        text-align: center;
        pointer-events: none;
        z-index: 10;
      }
      #phase-display.good-wins {
        color: var(--townsfolk-color);
        opacity: 1;
      }
      #phase-display.evil-wins {
        color: var(--demon-color);
        opacity: 1;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      .circle-container {
        position: relative;
        width: 725px;
        height: 725px;
        margin: 100px auto 40px;
        border: 2px dashed var(--border-color);
        border-radius: 50%;
      }

      .player-token {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 120px;
        height: 60px;
        margin: -30px 0 0 -60px;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;

        border: 3px solid yellow;
        border-radius: 8px;
        background-color: var(--card-bg);
        font-size: 0.9em;

        transition: opacity 0.1s ease;
        user-select: none;

        transition: box-shadow 0.1s ease-out, transform 0.1s ease-out;
        will-change: transform, box-shadow;
      }

      .player-token.townsfolk:hover {
        box-shadow: 0 0 15px 3px var(--townsfolk-color);
      }
      .player-token.outsider:hover {
        box-shadow: 0 0 15px 3px var(--outsider-color);
      }
      .player-token.minion:hover {
        box-shadow: 0 0 15px 3px var(--minion-color);
      }
      .player-token.demon:hover {
        box-shadow: 0 0 15px 3px var(--demon-color);
      }

      /* dead ppl dont glow */
      .player-token.dead:hover {
        transform: none;
        box-shadow: none;
        cursor: not-allowed;
      }

      /* Style for dead players */
      .player-token.dead {
        opacity: 0.4;
      }
      .player-token.dead strong,
      .player-token.dead span {
        text-decoration: line-through;
      }

      .player-token strong {
        font-size: 1.1em;
        color: var(--text-color);
      }
      .player-token span {
        font-weight: bold;
      }

      /* Color coding the tokens by role type */
      .player-token.townsfolk {
        border-color: var(--townsfolk-color);
      }
      .player-token.townsfolk span {
        color: var(--townsfolk-color);
      }

      .player-token.outsider {
        border-color: var(--outsider-color);
      }
      .player-token.outsider span {
        color: var(--outsider-color);
      }

      .player-token.minion {
        border-color: var(--minion-color);
      }
      .player-token.minion span {
        color: var(--minion-color);
      }

      .player-token.demon {
        border-color: var(--demon-color);
      }
      .player-token.demon span {
        color: var(--demon-color);
      }
    </style>
  </head>
  <body>
    <div class="container" id="container">
      <div class="controls">
        <label for="player-count">Select Player Count:</label>
        <select id="player-count">
          <option value="7">7 Players</option>
          <option value="8">8 Players</option>
          <option value="9">9 Players</option>
          <option value="10">10 Players</option>
          <option value="11">11 Players</option>
          <option value="12" selected>12 Players</option>
          <option value="13">13 Players</option>
          <option value="14">14 Players</option>
          <option value="15">15 Players</option>
        </select>
        <button id="generate-btn">New Game</button>
      </div>
      <div id="player-assignments">
        <div id="phase-display"></div>
        <button id="center-action-btn"></button>
        <div class="circle-container" id="circle-container">
          <!-- players appear here -->
        </div>
        <div id="mode-controls">
          <button id="kill-mode-toggle">Execute Mode: OFF</button>
        </div>
      </div>
    </div>

    <script>
      // --- DATA ---
      const characters = {
        townsfolk: [
          {
            name: "Washerwoman",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Librarian",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Investigator",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Chef",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Empath",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Fortune Teller",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Undertaker",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Monk",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Ravenkeeper",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Virgin",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Slayer",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Soldier",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Mayor",
            type: "townsfolk",
            evil: false,
          },
        ],
        outsiders: [
          {
            name: "Butler",
            type: "outsider",
            evil: false,
          },
          {
            name: "Drunk",
            type: "outsider",
            evil: false,
          },
          {
            name: "Recluse",
            type: "outsider",
            evil: false,
          },
          {
            name: "Saint",
            type: "outsider",
            evil: false,
          },
        ],
        minions: [
          {
            name: "Poisoner",
            type: "minion",
            evil: true,
          },
          {
            name: "Spy",
            type: "minion",
            evil: true,
          },
          {
            name: "Scarlet Woman",
            type: "minion",
            evil: true,
          },
          {
            name: "Baron",
            type: "minion",
            evil: true,
          },
        ],
        demons: [
          {
            name: "Imp",
            type: "demon",
            evil: true,
          },
        ],
      };

      const playerCounts = {
        7: { townsfolk: 5, outsiders: 0, minions: 1, demons: 1 },
        8: { townsfolk: 5, outsiders: 1, minions: 1, demons: 1 },
        9: { townsfolk: 5, outsiders: 2, minions: 1, demons: 1 },
        10: { townsfolk: 7, outsiders: 0, minions: 2, demons: 1 },
        11: { townsfolk: 7, outsiders: 1, minions: 2, demons: 1 },
        12: { townsfolk: 7, outsiders: 2, minions: 2, demons: 1 },
        13: { townsfolk: 9, outsiders: 0, minions: 3, demons: 1 },
        14: { townsfolk: 9, outsiders: 1, minions: 3, demons: 1 },
        15: { townsfolk: 9, outsiders: 2, minions: 3, demons: 1 },
      };

      const playerNames = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "R",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
      ];

      // --- Ugly Number Data ---
      const chefNumbers = {
        7: [27112, 12350, 538, 0, 0, 0],
        8: [26668, 12319, 1013, 0, 0, 0],
        9: [26484, 12371, 1145, 0, 0, 0],
        10: [18741, 17440, 3617, 202, 0, 0],
        11: [18805, 16849, 4081, 265, 0, 0],
        12: [18988, 16524, 4198, 290, 0, 0],
        13: [12975, 18240, 7589, 1154, 42, 0],
        14: [13158, 18012, 7590, 1185, 55, 0],
        15: [13333, 17744, 7654, 1216, 53, 0],
      };

      const empathNumbers = {
        7: [16879, 20466, 2655],
        8: [18879, 18829, 2292],
        9: [20297, 17582, 2121],
        10: [17619, 19346, 3035],
        11: [18810, 18325, 2865],
        12: [19917, 17450, 2633],
        13: [17955, 18716, 3329],
        14: [18866, 18100, 3034],
        15: [19819, 17461, 2720],
      };

      // --- Dom Elements ---
      const playerCountSelect = document.getElementById("player-count");
      const generateBtn = document.getElementById("generate-btn");
      const circleContainer = document.getElementById("circle-container");
      const container = document.getElementById("container");
      const phaseDisplay = document.getElementById("phase-display");
      const centerActionButton = document.getElementById("center-action-btn");
      const killModeToggleBtn = document.getElementById("kill-mode-toggle");

      // magic numbers
      let nightPhaseMS = 1500;

      // game state variables
      let evilHasGrim = false;
      let currentPhase = "day";
      let phaseNumber = 1;
      let previousExecution = null;
      let gameStatePlayers = [
        /*{
        seat: 0,
        name: "ABCDEFG"
        character:  "drunk",
        type: "outsider"
        evil: true/false     // only 2 alignments in botc
        alive: true/false
        appears_as: {role: "mayor", type: "townsfolk"}
        my_info_text: "A/B yes, C/D no",
        gameover_text: "i saw myself as mayor",
        droisoned: true/false
        previous_info: [] // some array of useful info for me...?
      }*/
      ];

      killModeToggleBtn.addEventListener("click", () => toggleKillModeBtn());

      // ui state variables
      let currentCenterAction = null;
      let canExecutePlayer = true;
      let isKillMode = false;
      let isActionMode = false;
      let gameEnded = false;
      // when a slayer (or false-slayer) is selected to act, store their seat
      let currentActor = null;
      // track deaths that should appear visually at day start
      let deferredDeaths = [];

      function toggleKillModeBtn() {
        // Turning on kill-mode will turn off action-mode
        if (isActionMode) {
          isActionMode = false;
          document.body.classList.toggle("action-mode-active", false);
          container.classList.toggle("action-mode-active", false);
          // clear any selection
          currentActor = null;
          setupCenterButton(null, null, false);
          // redraw tokens so action-ready badges and action-mode visuals disappear immediately
          displayPlayerCircle(false);
        }
        isKillMode = !isKillMode;
        document.body.classList.toggle("kill-mode-active", isKillMode);
        container.classList.toggle("kill-mode-active", isKillMode);

        if (isKillMode) {
          killModeToggleBtn.textContent = "Execute Mode: ON";
          // If it's daytime, show the "No Execution" button
          if (currentPhase === "day") {
            setupCenterButton("No Execution", () => executePlayer(null, -1));
          }
        } else {
          killModeToggleBtn.textContent = "Execute Mode: OFF";
          // Always hide the button when not in kill mode
          setupCenterButton(null, null, false);
        }
        // refresh the circle tokens so cursor and visuals reflect the new mode
        displayPlayerCircle(false);
      }

      function updatePhaseDisplay() {
        if (phaseDisplay) {
          // Check that the element exists
          phaseDisplay.textContent = `${currentPhase.toUpperCase()} ${phaseNumber}`;
        }
      }

      // --- UI Logic ---

      function setupCenterButton(text, action, isVisible = true) {
        if (isVisible) {
          centerActionButton.textContent = text;
          // If it's a Cancel button, automatically exit action mode
          if (text === "Cancel") {
            currentCenterAction = () => {
              currentActor = null;
              isActionMode = false;
              document.body.classList.toggle("action-mode-active", false);
              container.classList.toggle("action-mode-active", false);
              setupCenterButton(null, null, false);
              displayPlayerCircle(false);
              if (action) action(); // Call any additional action provided
            };
          } else {
            currentCenterAction = action; // Assign the function to our variable
          }
          centerActionButton.classList.add("visible");
        } else {
          centerActionButton.classList.remove("visible");
          currentCenterAction = null; // Clear the action
        }
      }

      // --- GAME LOGIC ---
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function getRandomItems(array, numItems) {
        const shuffled = shuffleArray([...array]);
        const selected = shuffled.slice(0, numItems);
        const notSelected = shuffled.slice(numItems);
        return { selected, notSelected };
      }
      function getRandomItem(array) {
        return getRandomItems(array, 1).selected[0];
      }

      function transitionToNight() {
        setupCenterButton(null, null, false); // Hide the button during the night
        // Action mode is only for the day ‚Äî clear it as we transition
        if (isActionMode) {
          isActionMode = false;
          currentActor = null;
          document.body.classList.toggle("action-mode-active", false);
          container.classList.toggle("action-mode-active", false);
        }
        currentPhase = "night";
        canExecutePlayer = false; // No more executions
        phaseNumber++;
        updatePhaseDisplay();
        deferredDeaths = []; // Reset deferred deaths for this night
        othernights();
        setTimeout(() => {
          // Check if the game ended during othernights (e.g., final 4 reaching <= 2 alive with demon)
          if (gameEnded) {
            return;
          }
          // Apply visual updates for night kills when day starts
          deferredDeaths.forEach((playerSeat) => {
            const playerToken = circleContainer.children[playerSeat];
            if (playerToken) {
              playerToken.classList.add("dead");
            }
          });
          deferredDeaths = [];
          currentPhase = "day";
          canExecutePlayer = true;
          updatePhaseDisplay();
          displayPlayerCircle(false);
          // When the day starts, show the button again if we are in kill mode
          if (isKillMode) {
            setupCenterButton("No Execution", transitionToNight);
          }
        }, nightPhaseMS);
      }

      function killPlayer(playerToken, id, delayVisual = false) {
        const player = gameStatePlayers[id];
        player.alive = false;
        if (!delayVisual) {
          playerToken.classList.add("dead");
        }
        return id; // return the id for deferred visual updates
      }

      function checkGameEndConditions() {
        const alivePlayers = gameStatePlayers.filter((p) => p.alive);

        // if all remaining alive players are evil, evil wins
        const allEvilAlive = alivePlayers.every((p) => p.evil);
        if (allEvilAlive && alivePlayers.length > 0) {
          endGame(false);
          return true;
        }

        // if 2 or less players are alive, and a demon is alive, evil wins.
        if (alivePlayers.length <= 2) {
          const demon = alivePlayers.find((p) => p.type === "demon");
          if (demon) {
            endGame(false);
            return true;
          }
        }

        return false;
      }

      function starpass() {
        // TODO: this
        // if a scarlet woman is alive + 5+ alive you pass to the scarlet woman
        // otherwise you pass to a random minion
      }

      function executePlayer(playerToken, id) {
        // execution is not allowed during night phase
        if (!canExecutePlayer) {
          return;
        }

        const aliveCount = gameStatePlayers.filter((p) => p.alive).length;
        // no execution
        if (playerToken === null) {
          // check for mayor win
          const mayor = getRoleIfInPlay("Mayor");
          previousExecution = null;
          if (
            aliveCount === 3 &&
            mayor &&
            mayor.alive &&
            mayor.droisoned === false
          ) {
            // if mayor is alive in F3 and NOT droisoned, good wins
            endGame(true);
            return;
          }
        } else {
          // yes execution
          const player = gameStatePlayers[id];
          previousExecution = player;
          killPlayer(playerToken, id);
          const scarletWoman = getRoleIfInPlay("Scarlet Woman");
          if (player.role === "Imp") {
            // if the imp is executed, and the scarlet woman either does not exist, is dead, or is poisoned (lol)
            // or there is less than 5 players alive
            // then the evil team loses.

            const evilLoses =
              !scarletWoman ||
              !scarletWoman.alive ||
              scarletWoman.droisoned ||
              aliveCount < 5;
            if (evilLoses) {
              endGame(true);
              return;
            }
            // otherwise the scarlet woman becomes the imp
            scarletWoman.role = "Imp";
            scarletWoman.type = "demon";
          }

          // if a healthy saint is executed, their team loses.
          if (player.role === "Saint" && player.droisoned === false) {
            endGame(player.evil);
            return;
          }

          // Check for all evil win or demon win conditions
          if (checkGameEndConditions()) {
            return;
          }
        }
        if (isKillMode) toggleKillModeBtn();
        transitionToNight();
      }

      // Slayer shoot action: shooterSeat shoots targetSeat during day via action mode
      function slayerShoot(shooterSeat, targetSeat) {
        const shooter = gameStatePlayers[shooterSeat];
        const target = gameStatePlayers[targetSeat];

        if (!shooter || !target || !shooter.alive || !target.alive) return;
        if (shooter.shotUsed) return; // already used

        // mark shooter used and update texts
        shooter.shotUsed = true;
        shooter.actionmodeText = null;
        shooter.info_text = `I shot ${target.name}`;

        // Exit action mode immediately after the slayer takes their shot
        if (isActionMode) {
          isActionMode = false;
          currentActor = null;
          document.body.classList.toggle("action-mode-active", false);
          container.classList.toggle("action-mode-active", false);
          // hide center button if visible (cancel button or similar)
          setupCenterButton(null, null, false);
        }

        // determine whether this shot actually has an effect
        // False-slayers (players who only appear as Slayer e.g. drunk or evil bluff) have no effect
        // A real slayer who is droisoned cannot kill an Imp or a Recluse
        const shooterIsRealSlayer = shooter.role === "Slayer";
        let shotEffective = false;

        if (!shooterIsRealSlayer) {
          // fake ‚Äî no effect
          shotEffective = false;
        } else {
          // real slayer
          shooter.gameover_text = shooter.info_text;
          markPoisonedInfoIfApplicable(shooter);
          if (
            !shooter.droisoned &&
            (target.role === "Imp" || target.role === "Recluse")
          ) {
            // a healthy slayer can kill an imp or a recluse
            shotEffective = true;
          } else {
            shotEffective = false;
          }
        }

        let killed = false;

        if (shotEffective) {
          if (target.role === "Imp") {
            // imp dies
            const targetToken = circleContainer.children[targetSeat];
            killPlayer(targetToken, targetSeat);
            killed = true;

            // if there is a scarlet woman alive and not droisoned and enough players remain, convert her to the Imp
            const scarletWoman = getRoleIfInPlay("Scarlet Woman");
            const aliveCount = gameStatePlayers.filter((p) => p.alive).length;
            const evilLoses =
              !scarletWoman ||
              !scarletWoman.alive ||
              scarletWoman.droisoned ||
              aliveCount < 5;
            if (evilLoses) {
              endGame(true);
              return true; // game ended
            }
            // otherwise the scarlet woman becomes the imp
            scarletWoman.role = "Imp";
            scarletWoman.type = "demon";
          } else if (target.role === "Recluse") {
            // recluse only dies rarely (5% chance)
            if (percentTrue(5)) {
              const targetToken = circleContainer.children[targetSeat];
              killPlayer(targetToken, targetSeat);
              killed = true;
            }
          } else {
            // Non-Imp/non-Recluse targets do NOT die from a slayer shot ‚Äî the shot is consumed and nothing else happens
            // killed remains false
          }
        } else {
          // shot had no effect (false slayer or restricted droisoned slayer) ‚Äî nothing else to do
        }

        // after shot, check for trivial endgame conditions similar to execution
        if (killed) {
          if (checkGameEndConditions()) {
            return true;
          }
        }

        // if we got here no endGame was triggered
        return false;
      }

      // Virgin nominate action: actorSeat (appears as Virgin) asks who nominated them.
      // If the actor is a real, sober Virgin and the nominator is a townsfolk, that nominator is executed immediately and the day ends.
      // If the actor is droisoned or not actually the Virgin, they lose the ability and their info_text is updated.
      function virginNominate(actorSeat, nominatorSeat) {
        const actor = gameStatePlayers[actorSeat];
        const nominator = gameStatePlayers[nominatorSeat];

        if (!actor || !nominator || !actor.alive || !nominator.alive)
          return false;
        if (actor.shotUsed) return false; // already used

        // consume the virgin's action
        actor.shotUsed = true;
        actor.actionmodeText = null;
        const nominationText = `${nominator.name} nominated me`;
        actor.info_text = nominationText;
        if (actor.role === "Virgin") {
          actor.gameover_text = nominationText;
          markPoisonedInfoIfApplicable(actor);
        }

        // Exit action mode immediately after acting
        if (isActionMode) {
          isActionMode = false;
          currentActor = null;
          document.body.classList.toggle("action-mode-active", false);
          container.classList.toggle("action-mode-active", false);
          setupCenterButton(null, null, false);
        }

        const actorIsRealVirgin = actor.role === "Virgin";

        // Only a real, sober Virgin punishes certain nominators
        if (actorIsRealVirgin && !actor.droisoned) {
          if (nominator.role === "Spy") {
            // If the Spy is claiming outsider, they never die to the Virgin's ability
            if (nominator.appears_as.type === "outsider") {
              // Spy survives, nothing happens
            } else {
              // Spy has a 50/50 chance of being executed when they nominate the Virgin
              if (percentTrue(50)) {
                const nominatorToken = circleContainer.children[nominatorSeat];
                executePlayer(nominatorToken, nominatorSeat);
                return true;
              }
              // Spy survived the 50/50 ‚Äî nothing else
            }
          } else if (nominator.type === "townsfolk") {
            // execute the nominator immediately (this will handle endgame checks and transition to night)
            const nominatorToken = circleContainer.children[nominatorSeat];
            executePlayer(nominatorToken, nominatorSeat);
            return true; // day ended via execution/transition
          }
        }

        // Otherwise the ability is lost, nothing else happens and the day continues
        displayPlayerCircle(false);
        return false;
      }

      function getRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.role === role) {
            return player;
          }
        }
        return null;
      }

      function getRoleIfAlive(role) {
        for (player of gameStatePlayers) {
          if (player.role === role && player.alive) {
            return player;
          }
        }
      }

      function getRoleIfHealthy(role) {
        const result = getRoleIfInPlay(role);
        return result && !result.droisoned;
      }

      function getAppearsAsIfAlive(role) {
        for (player of gameStatePlayers) {
          if (player.appears_as.role === role && player.alive) {
            return player;
          }
        }
        return null;
      }

      function getAppearAsRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.appears_as.role === role) {
            return player;
          }
        }
        return null;
      }

      function flipCoin() {
        return percentTrue(50);
      }

      function percentTrue(percent) {
        return Math.random() < percent / 100;
      }

      function weightedRandom(distribution, exclude = []) {
        const filtered = distribution.map((w, i) =>
          exclude.includes(i) ? 0 : w
        );
        const total = filtered.reduce((a, b) => a + b, 0);
        if (total === 0)
          throw new Error("No valid options left after exclusions.");
        let r = Math.random() * total;
        for (let i = 0; i < filtered.length; i++) {
          r -= filtered[i];
          if (r < 0) return i;
        }
      }

      function countEvilPairs(players, recluseEvil, spyEvil) {
        let evilPairs = 0;
        const n = players.length;

        for (let i = 0; i < n; i++) {
          const current = players[i];
          const next = players[(i + 1) % n]; // wraps around to 0 at the end
          const currentEvil =
            current.role === "Recluse"
              ? recluseEvil
              : current.role === "Spy"
              ? spyEvil
              : current.evil;
          const nextEvil =
            next.role === "Recluse"
              ? recluseEvil
              : next.role === "Spy"
              ? spyEvil
              : next.evil;

          if (currentEvil && nextEvil) evilPairs++;
        }
        return evilPairs;
      }

      function getAllOutsiders() {
        return gameStatePlayers.filter((p) => p.type === "outsider");
      }

      function appendInfoText(player, text, poisoned = false) {
        if (!player.info_text) {
          player.info_text = text;
        } else {
          player.info_text += `, ${text}`;
        }
        // Track per-entry poisoning for accurate gameover tagging
        if (!player.info_log) player.info_log = [];
        player.info_log.push({ text, poisoned });
      }

      function rebuildGameoverFromInfoLog(player) {
        if (!player || !player.info_log || player.info_log.length === 0) {
          player.gameover_text = player.info_text || player.gameover_text || "";
          return;
        }
        const parts = player.info_log.map(({ text, poisoned }) =>
          poisoned && !player.evil && player.role !== "Drunk"
            ? `${text} üß™`
            : text
        );
        player.gameover_text = parts.join(", ");
      }

      function checkIsBaronPossible() {
        const outsiderClaims = gameStatePlayers.filter(
          (p) => p.appears_as.type === "outsider"
        );
        const outsiderCount = playerCounts[gameStatePlayers.length].outsiders;
        return outsiderClaims > outsiderCount;
      }

      function appendPreviousInfo(player, info) {
        if (!player.previous_info) {
          player.previous_info = [info];
        } else {
          player.previous_info.push(info);
        }
      }

      // If a good, non-Drunk player learned/used info while droisoned,
      // add a üß™ tag next to their info in gameover_text.
      function markPoisonedInfoIfApplicable(player) {
        if (
          player &&
          player.droisoned &&
          !player.evil &&
          player.role !== "Drunk"
        ) {
          if (!player.gameover_text)
            player.gameover_text = player.info_text || "";
          if (player.gameover_text && !player.gameover_text.includes("üß™")) {
            player.gameover_text = `${player.gameover_text} üß™`;
          }
        }
      }

      function getLivingNeighbors(index) {
        const players = gameStatePlayers;
        const n = players.length;

        let left = (index - 1 + n) % n;
        while (left !== index && !players[left].alive) {
          left = (left - 1 + n) % n;
        }
        if (!players[left].alive) left = null;

        let right = (index + 1) % n;
        while (right !== index && !players[right].alive) {
          right = (right + 1) % n;
        }
        if (!players[right].alive) right = null;

        return { left, right };
      }

      // TODO: virgin bluff goes to the least valuable evil player

      function night1() {
        // Poisoner: on night 1, if alive, picks a player to poison.
        // Track previous target for healing at the start of future nights.
        let poisoner = getRoleIfInPlay("Poisoner");
        if (poisoner && poisoner.alive) {
          // pick a random living player other than the poisoner
          const livingOthers = gameStatePlayers.filter(
            (p) => p.alive && p.seat !== poisoner.seat && !p.evil
          );
          if (livingOthers.length > 0) {
            const target = getRandomItem(livingOthers);
            console.log("Poisoner hit", target.name);
            // If target is Drunk, they are already permanently droisoned; picking them does nothing
            if (target.role !== "Drunk") {
              target.droisoned = true;
              poisoner.previousPoisonTarget = target.seat;
            } else {
              // ensure we don't track Drunk for healing
              poisoner.previousPoisonTarget = null;
            }
          }
        }

        // picks a random good player and is more likely to pick someone neighboring the demon.
        let washerwoman = getAppearAsRoleIfInPlay("Washerwoman");
        if (washerwoman) {
          const spy = getRoleIfInPlay("Spy");
          let theDrunk = getRoleIfInPlay("Drunk");
          if (theDrunk && theDrunk.seat === washerwoman.seat) theDrunk = null;
          const evilWasherwoman = washerwoman.evil;
          const droisoned = washerwoman.droisoned;

          // pre-select an evil bluffing a townsfolk to confirm,
          // but not an evil washerwoman.
          // the drunk counts as an "evil player" for these purposes
          // there may be no one that meets this criteria.
          const evilsBluffingTownsfolk = gameStatePlayers.filter(
            (player) =>
              player.evil &&
              player.appears_as.type === "townsfolk" &&
              player.appears_as.role !== "Washerwoman"
          );
          const evilsAndDrunkBluffingTownsfolk = theDrunk
            ? [...evilsBluffingTownsfolk, theDrunk]
            : evilsBluffingTownsfolk;

          let evilToConfirm =
            evilsBluffingTownsfolk.length > 0
              ? getRandomItem(evilsBluffingTownsfolk)
              : null;
          let evilOrDrunkToConfirm =
            evilsAndDrunkBluffingTownsfolk.length > 0
              ? getRandomItem(evilsAndDrunkBluffingTownsfolk)
              : null;

          let correct;
          let wrong;
          let text;
          let seenRole;

          let confirmEvil = false;
          let confirmEvilOrDrunk = false;
          let learnRealInfo = false;
          let learnGarbage = false;

          if (evilWasherwoman) {
            // if no evil to confirm and no spy do random stuff
            if (!evilToConfirm && !spy) learnGarbage = true;
            // evil washerwoman confirms an allied evil player
            if (evilToConfirm && !spy) confirmEvil = true;
            // if spy in play but no evil to confirm, confirm a good player even tho ur evil lol ;)
            if (!evilToConfirm && spy) learnRealInfo = true;
            // if spy in play and evil to confirm u can confirm anyone good or evil
            if (evilToConfirm && spy) {
              if (percentTrue(33)) learnRealInfo = true;
              else confirmEvilOrDrunk = true;
            }
          } else if (droisoned) {
            // if no one is available to falsely confirm learn garbage
            if (!evilToConfirm) learnGarbage = true;
            // droisoned washerwoman falsely confirms sonmeone, or does random stuff (small chance)
            else if (percentTrue(10)) learnGarbage = true;
            else confirmEvilOrDrunk = true;
          } else if (spy) {
            // if spy in play, washerwoman picks a random townsfolk claim (even the drunk!) and confirms them
            const townsfolkClaims = gameStatePlayers.filter(
              (player) =>
                player.appears_as.type === "townsfolk" &&
                player.seat !== washerwoman.seat
            );
            const townsfolkToConfirm = getRandomItem(townsfolkClaims);
            seenRole = townsfolkToConfirm.appears_as.role;
            correct = townsfolkToConfirm;
            // if washerwoman would learn false info, the spy is the wrong side of the ping
            // unless they are confirming the spy's bluff in which case someone random is the wrong side
            const needsSpyWrong =
              townsfolkToConfirm.role.type !== "townsfolk" &&
              townsfolkToConfirm.role !== "Spy";
            if (needsSpyWrong) wrong = spy;
          } else {
            // if no spy in play, healthy washerwoman confirms a random good townsfolk
            learnRealInfo = true;
          }
          if (learnRealInfo) {
            const realTownsfolk = gameStatePlayers.filter(
              (player) =>
                player.type === "townsfolk" && player.seat !== washerwoman.seat
            );
            const townsfolkToConfirm = getRandomItem(realTownsfolk);
            correct = townsfolkToConfirm;
            seenRole = townsfolkToConfirm.role;
          } else if (confirmEvil) {
            correct = evilToConfirm;
            seenRole = evilToConfirm.appears_as.role;
          } else if (confirmEvilOrDrunk) {
            correct = evilOrDrunkToConfirm;
            seenRole = evilOrDrunkToConfirm.appears_as.role;
          } else if (learnGarbage) {
            // pick a random player (not yourself) and see a random townsfolk (not washerwoman).
            correct = getRandomItem(
              gameStatePlayers.filter(
                (player) => player.seat !== washerwoman.seat
              )
            );
            seenRole = getRandomItem(characters.townsfolk.slice(1)).name;
          }

          if (!wrong) {
            wrong = getRandomItem(
              gameStatePlayers.filter(
                (player) =>
                  player.seat !== correct.seat &&
                  player.seat !== washerwoman.seat
              )
            );
          }

          const order = flipCoin();
          text = `${order ? correct.name : wrong.name}/${
            order ? wrong.name : correct.name
          } ${seenRole}`;
          washerwoman.info_text = text;
          if (!washerwoman.evil) {
            washerwoman.gameover_text = text;
            markPoisonedInfoIfApplicable(washerwoman);
          }
        }
        // librarian
        let librarian = getAppearAsRoleIfInPlay("Librarian");
        if (librarian) {
          const spy = getRoleIfInPlay("Spy");
          const outsiders = getAllOutsiders();
          const zeroOutsidersPossible =
            gameStatePlayers.length === 7 ||
            gameStatePlayers.length === 10 ||
            gameStatePlayers.length === 13;
          const healthyLibrarian = !librarian.droisoned && !librarian.evil;
          const evilLibrarian = librarian.evil;
          // magic 1/5 chance for a healthy to ping off the spy
          // evil/drunk librarian has no need for a spy to misregister.
          const pingsOffSpy = healthyLibrarian && spy ? percentTrue(20) : false;
          // find all evil ppl bluffing outsider
          const evilOutsiders = gameStatePlayers.filter(
            (player) => player.evil && player.appears_as.type === "outsider"
          );
          let correct;
          let wrong;
          let text;
          let seenRole;

          let learnZero = false;
          let confirmEvil = false;
          let learnRealInfo = false;
          let learnRandomDrunk = false;
          let learnGarbage = false;

          if (pingsOffSpy) {
            // spy misinfo
            const mustConfirmSpy = spy.appears_as.type === "outsider";
            if (evilOutsiders.length === 0) {
              // random drunk ping
              correct = spy;
              seenRole = "Drunk";
            } else {
              // if spy is bluffing outsider confirm the spy
              if (mustConfirmSpy) {
                // confirm the spy
                correct = spy;
                seenRole = spy.appears_as.role;
              } else {
                // 3/4 confirm evil player. 1/4 drunk ping
                const confirmEvil = percentTrue(75);
                if (confirmEvil) {
                  // confirm an evil player
                  correct = getRandomItems(evilOutsiders, 1).selected[0];
                  wrong = spy;
                  seenRole = correct.appears_as.role;
                } else {
                  // spy influenced drunk ping
                  correct = spy;
                  seenRole = "Drunk";
                }
              }
            }
          } else if (healthyLibrarian) {
            if (outsiders.length === 0) {
              // if there's no outsiders you cannot learn any
              learnZero = true;
            } else {
              // learn a real outsider
              learnRealInfo = true;
            }
          } else {
            // librarian is droisoned/evil and will give harmful info
            const isBaronInPlay = !!getRoleIfInPlay("Baron");
            // the priority is to confirm your evil ally
            if (evilOutsiders.length > 0) {
              confirmEvil = true;
            } else if (evilHasGrim) {
              const confirmGoodPlayer = percentTrue(75);
              // confirm a good player for the cred
              if (confirmGoodPlayer) {
                if (outsiders.length === 0) {
                  // if there's no outsiders you cannot learn any
                  learnZero = true;
                } else {
                  // learn a real outsider
                  learnRealInfo = true;
                }
              } else {
                if (zeroOutsidersPossible && !isBaronInPlay) {
                  // claim 0 outsiders
                  learnZero = true;
                } else {
                  // make up a drunk ping
                  learnRandomDrunk = true;
                }
              }
            } else {
              if (zeroOutsidersPossible && !isBaronInPlay) {
                // claim 0 outsiders
                learnZero = true;
              } else {
                // make up a drunk ping
                learnRandomDrunk = true;
              }
            }
          }

          //  now that the action is decided execute the action
          if (learnZero) {
            text = "0";
          } else if (confirmEvil) {
            const evilAlly = getRandomItems(evilOutsiders, 1).selected[0];
            correct = evilAlly;
            seenRole = evilAlly.appears_as.role;
          } else if (learnRealInfo) {
            correct = getRandomItems(outsiders, 1).selected[0];
            seenRole = correct.role;
          } else if (learnRandomDrunk) {
            const anyoneButMe = getRandomItems(
              gameStatePlayers.filter((x) => x.seat !== librarian.seat),
              1
            ).selected[0];
            correct = anyoneButMe;
            seenRole = "Drunk";
          }

          if (correct) {
            if (!wrong) {
              wrong = getRandomItems(
                gameStatePlayers.filter(
                  (player) =>
                    player.seat !== correct.seat &&
                    player.seat !== librarian.seat
                ),
                1
              ).selected[0];
            }
            const order = flipCoin();
            text = `${order ? correct.name : wrong.name}/${
              order ? wrong.name : correct.name
            } ${seenRole}`;
          }
          if (!librarian.evil) {
            librarian.gameover_text = text;
            markPoisonedInfoIfApplicable(librarian);
          }
          librarian.info_text = text;
        }

        // investigator
        let invest = getAppearAsRoleIfInPlay("Investigator");
        if (invest) {
          const healthyInvest = !invest.droisoned && !invest.evil;
          const evilInvest = invest.evil;
          const isBaronPossible = checkIsBaronPossible();

          // outcomes
          let learnRealInfo = false;
          let learnRecluse = false;
          let learnGoodPlayers = false;
          let correct;
          let wrong;
          let seenRole;
          let text;

          // sober investigators have 20% to get trolled by a recluse
          if (healthyInvest && getRoleIfHealthy("Recluse") && percentTrue(20))
            learnRecluse = true;

          // sober investigator learns a minion. priority is on non-scarlet woman
          // might get trolled by a recluse.
          if (healthyInvest && !learnRecluse) learnRealInfo = true;
          // drunk investigator sees a random minion (again probably not SW) between 2 good ppl.
          if (!healthyInvest && !evilInvest) learnGoodPlayers = true;

          // evil investigator
          if (evilInvest) {
            const minionsToBus = gameStatePlayers.filter(
              (p) =>
                p.type === "minion" &&
                p.role !== "Scarlet Woman" &&
                p.seat !== invest.seat
            );
            const existsMinionToBus =
              invest.type === "demon" || minionsToBus.length > 0;
            if (percentTrue(15) && existsMinionToBus) learnRealInfo = true;
            else learnGoodPlayers = true;
          }
          const randomMinionArray = ["Poisoner", "Spy"];
          const minionCount = playerCounts[gameStatePlayers.length].minions;
          // if 1 minion in play: learn a random minion
          if (minionCount === 1) randomMinionArray.push("Scarlet Woman");
          isBaronPossible && randomMinionArray.push("Baron");
          const goodPpl = gameStatePlayers.filter(
            (p) => !p.evil && p.seat !== invest.seat
          );
          if (learnRealInfo) {
            // if 1 minion in play: learn that minion
            if (minionCount === 1) {
              const minion = gameStatePlayers.filter(
                (p) => p.type === "minion"
              )[0];
              correct = minion;
              seenRole = minion.role;
            } else {
              // if 2+ minions in play: learn one that isnt the scarlet woman (and not yourself lol)
              const minions = gameStatePlayers.filter(
                (p) =>
                  p.type === "minion" &&
                  p.role !== "Scarlet Woman" &&
                  p.seat !== invest.seat
              );
              if (minions.length === 0) throw "NO MINION ERROR";
              correct = getRandomItem(minions);
              seenRole = correct.role;
            }
          } else if (learnRecluse) {
            const recluse = getRoleIfInPlay("Recluse");
            correct = recluse;
            seenRole = getRandomItem(randomMinionArray);
          } else if (learnGoodPlayers) {
            const picks = getRandomItems(goodPpl, 2).selected;
            correct = picks[0];
            wrong = picks[1];
            seenRole = getRandomItem(randomMinionArray);
          }

          // wrong is always a good player.
          if (!wrong) {
            const validWrongChoices = goodPpl.filter(
              (p) => p.seat !== correct.seat
            );
            const finalWrongChoices =
              seenRole === "Baron"
                ? validWrongChoices.filter(
                    (p) => p.role !== "Saint" && p.role !== "Butler"
                  )
                : validWrongChoices;
            wrong = getRandomItem(finalWrongChoices);
          }
          const order = flipCoin();
          text = `${order ? correct.name : wrong.name}/${
            order ? wrong.name : correct.name
          } ${seenRole}`;
          if (!invest.evil) {
            invest.gameover_text = text;
            markPoisonedInfoIfApplicable(invest);
          }
          invest.info_text = text;
        }
        // chef
        let chef = getAppearAsRoleIfInPlay("Chef");
        if (chef) {
          // check how many evil players are sitting next to each other in the circle
          const recluseEvil = getRoleIfHealthy("Recluse") && flipCoin(); // the recluse is evil for chef # if he is in the game, sober, and 50% chance
          const spyEvil = flipCoin();
          let correctEvilPairs = countEvilPairs(
            gameStatePlayers,
            recluseEvil,
            spyEvil
          );
          // although it is technically possible, i will never give a chef 5.
          if (correctEvilPairs === 5) correctEvilPairs = 4;
          let returnedEvilPairs = correctEvilPairs;

          // a droisoned chef gets false info
          if (chef.droisoned) {
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length],
              [correctEvilPairs]
            );
          } else if (chef.evil) {
            // an evil chef just says something random
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length]
            );
          } else {
            // a good chef learns the truth
            chef.gameover_text = `${returnedEvilPairs}`;
            markPoisonedInfoIfApplicable(chef);
          }
          chef.info_text = `${returnedEvilPairs}`;
        }
        // empath
        let empath = getAppearAsRoleIfInPlay("Empath");
        if (empath) {
          const { left, right } = getLivingNeighbors(empath.seat);
          const n1 = gameStatePlayers[left];
          const n2 = gameStatePlayers[right];

          const soberEmpath = !empath.droisoned && !empath.evil;
          const evilEmpath = empath.evil;
          const droisonedEmpath = empath.droisoned && !empath.evil;

          // set up a frame map for a drunk/evil empath.
          // if n2 is the SW/imp, n1 cannot be in the frame map
          // if n1 is the SW/imp, n2 cannot be in the frame map

          // the frame map picks N evil players out of all the players (not the empath, imp, or SW)
          // and says these are the evil ones.
          const impOrSw = (player) =>
            player &&
            (player.role === "Imp" || player.role === "Scarlet Woman");
          if (!empath.frame_map) {
            // Determine how many seats should be considered "evil" for false info
            const totalEvils = gameStatePlayers.filter((p) => p.evil).length;

            const excludedSeats = new Set([empath.seat]);
            gameStatePlayers.forEach((p) => {
              if (impOrSw(p)) excludedSeats.add(p.seat);
            });

            if (impOrSw(n2) && n1) excludedSeats.add(n1.seat);
            if (impOrSw(n1) && n2) excludedSeats.add(n2.seat);

            const frameCandidates = gameStatePlayers.filter(
              (p) => !excludedSeats.has(p.seat)
            );
            const selectCount = Math.min(totalEvils, frameCandidates.length);
            empath.frame_map = getRandomItems(
              frameCandidates,
              selectCount
            ).selected.map((p) => p.seat);
          }

          empath.spyEvil = flipCoin();
          empath.recluseEvil = flipCoin();
          let learnedNumber = 0;
          const frameMap = empath.frame_map || [];
          // sober+good empath gets true info, might misregister on recluse/spy
          if (soberEmpath) {
            [n1, n2].forEach((player) => {
              if (
                player.evil ||
                (player.role === "Recluse" && empath.recluseEvil) ||
                (player.role === "Spy" && empath.spyEvil)
              )
                learnedNumber++;
            });
          } else if (droisonedEmpath || evilEmpath) {
            // drunk empath gets random info, but must make demon/SW look good.
            // set up the frame map so that's the case
            learnedNumber = [n1, n2].reduce(
              (acc, player) =>
                acc + (player && frameMap.includes(player.seat) ? 1 : 0),
              0
            );
          }
          // evil empath frames their allies as good and may or may not claim a 1 or 2 on good ppl
          empath.info_text = `${n1.name}/${n2.name} ${learnedNumber}`;
          if (!empath.evil) {
            empath.gameover_text = empath.info_text;
            markPoisonedInfoIfApplicable(empath);
          }
        }
        // fortune teller
        let ft = getAppearAsRoleIfInPlay("Fortune Teller");
        if (ft) {
          // Night 1 Fortune Teller setup and initial check
          // 1) red_herring: any good player (including FT themself if good), but NOT a Recluse
          const goodNonRecluse = gameStatePlayers.filter(
            (p) => !p.evil && p.role !== "Recluse"
          );
          if (goodNonRecluse.length > 0) {
            const chosen = getRandomItem(goodNonRecluse);
            ft.red_herring = chosen.seat;
          } else {
            ft.red_herring = ft.seat;
          }

          // 2) frame_map: two different good players (not the fortune teller)
          const goodOthers = gameStatePlayers.filter(
            (p) => !p.evil && p.seat !== ft.seat
          );
          const frameSel = getRandomItems(
            goodOthers,
            Math.min(2, goodOthers.length)
          ).selected;
          ft.frame_map = frameSel.map((p) => p.seat);

          // Now perform the Night 1 check: pick 2 random players (may include yourself)
          const picks = getRandomItems(gameStatePlayers, 2).selected;
          const x = picks[0];
          const y = picks[1] || picks[0];

          // Helper to set result
          function setFTResult(res) {
            ft.info_text = `${x.name}/${y.name} ${res ? "Yes" : "No"}`;
            if (!ft.evil) {
              ft.gameover_text = ft.info_text;
              markPoisonedInfoIfApplicable(ft);
            }
          }

          const actorIsRealFT = ft.role === "Fortune Teller";
          const recluse = "Recluse";

          if (actorIsRealFT && !ft.droisoned && !ft.evil) {
            // healthy real FT: Yes if either is a demon or the red herring
            const eitherIsDemon = x.role === "Imp" || y.role === "Imp";
            const eitherIsRedHerring =
              x.seat === ft.red_herring || y.seat === ft.red_herring;
            // recluse special: 75% chance to trigger Yes if either is Recluse
            const recluseTrigger =
              ((x.role === recluse && !x.droisoned) ||
                (y.role === recluse && !y.droisoned)) &&
              percentTrue(75);
            if (eitherIsDemon || eitherIsRedHerring || recluseTrigger)
              setFTResult(true);
            else setFTResult(false);
          } else {
            // droisoned or evil FT: they learn YES if either seat is in the frame_map

            // TODO: however for evil FT recluse behavior
            // if my ally is bluffing recluse, 75% to learn a YES
            // if i have spy and i am checking a real recluse, 75% to learn a YES

            // so basically i care not if they're poisoned, just if they appear as recluse

            if (ft.evil) {
              const eitherIsRecluseClaim =
                x.role === recluse ||
                x.appears_as === recluse ||
                y.role === recluse ||
                y.appears_as === recluse;
              //
            }

            // TODO: the todo above

            const inFrame =
              ft.frame_map &&
              (ft.frame_map.includes(x.seat) || ft.frame_map.includes(y.seat));

            setFTResult(!!inFrame);
          }
        }
      }

      function othernights() {
        // unpoison the previous poison target
        const poisoner = getRoleIfInPlay("Poisoner");
        if (poisoner && poisoner.previousPoisonTarget !== null) {
          const prev = gameStatePlayers[poisoner.previousPoisonTarget];
          if (prev && prev.role !== "Drunk") {
            prev.droisoned = false;
          }
          poisoner.previousPoisonTarget = null;
        }

        // TODO: more intelligent poisoner stuff.
        // if you have the grim, go crazy
        // if you don't have the grim, don't poison a slayer who shot or a virgin with no ability. (unless you have no other choice)

        // poisoner
        if (poisoner && poisoner.alive) {
          const livingOthers = gameStatePlayers.filter(
            (p) => p.alive && p.seat !== poisoner.seat && !p.evil
          );
          if (livingOthers.length > 0) {
            const target = getRandomItem(livingOthers);
            console.log("Poisoner hit", target.name);
            if (target.role !== "Drunk") {
              target.droisoned = true;
              poisoner.previousPoisonTarget = target.seat;
            } else {
              // Drunk remains permanently droisoned; picking them does nothing
              poisoner.previousPoisonTarget = null;
            }
          }
        }

        // Monk protection selection
        let monkSaved = null;
        const monk = getAppearsAsIfAlive("Monk");
        if (monk) {
          // Remove pending notation before processing night
          if (monk.info_text && monk.info_text.includes("(")) {
            monk.info_text = monk.info_text
              .replace(/, \([^)]+\)$/, "")
              .replace(/\([^)]+\)$/, "");
          }

          // If no target is set, auto-select a random living player (excluding the Monk)
          if (
            monk.monkChosenTarget === null ||
            monk.monkChosenTarget === undefined
          ) {
            const livingOthers = gameStatePlayers.filter(
              (p) => p.alive && p.seat !== monk.seat
            );
            const pool =
              livingOthers.length > 0
                ? livingOthers
                : gameStatePlayers.filter((p) => p.seat !== monk.seat);
            if (pool.length > 0) {
              const autoPick = getRandomItem(pool);
              monk.monkChosenTarget = autoPick.seat;
              monk.actionmodeText = `Protecting ${autoPick.name}`;
            }
          }

          const isRealMonk = monk.role === "Monk";
          // Only a real, sober Monk can protect someone
          if (isRealMonk && !monk.droisoned && monk.monkChosenTarget !== null) {
            const target = gameStatePlayers[monk.monkChosenTarget];
            if (target && target.alive) {
              monkSaved = monk.monkChosenTarget;
            }
          }

          // Log the monk's pick for the night (for all monks, including fake ones)
          if (monk.monkChosenTarget !== null) {
            const targetName = gameStatePlayers[monk.monkChosenTarget].name;
            appendInfoText(monk, targetName, !!monk.droisoned);
            if (!monk.evil) {
              rebuildGameoverFromInfoLog(monk);
              // Monk tracks their pick; if they were droisoned this night, mark it
              // (Handled in rebuild with per-entry tagging)
            }
          }

          // Do NOT reset chosen target; keep persisting the selection night-to-night
          if (monk.alive && monk.monkChosenTarget !== null) {
            const tgtName = gameStatePlayers[monk.monkChosenTarget].name;
            monk.actionmodeText = `Protecting ${tgtName}`;
            // ensure pending notation reflects current target
            if (monk.info_text && monk.info_text.includes("(")) {
              monk.info_text = monk.info_text
                .replace(/, \([^)]+\)$/, "")
                .replace(/\([^)]+\)$/, "");
            }
            if (!monk.info_text) {
              monk.info_text = `(${tgtName})`;
            } else {
              monk.info_text += `, (${tgtName})`;
            }
          } else if (monk.alive) {
            monk.actionmodeText = "Who should I protect tonight?";
          }
        }

        // Imp night kill
        const imp = getRoleIfAlive("Imp");
        let impKilledTonight = null;
        if (imp && imp.alive) {
          // Pick a random good (non-evil) player to kill
          const goodPlayers = gameStatePlayers.filter(
            (p) => p.alive && !p.evil && p.seat !== imp.seat
          );
          const evilPlayers = gameStatePlayers.filter(
            (p) => p.alive && p.evil && p.seat !== imp.seat
          );

          const killTargets =
            goodPlayers.length === 0 ? evilPlayers : goodPlayers;

          const target = getRandomItem(killTargets);

          // monk and soldier targets can't die
          let targetDies = true;

          if (target.role === "Soldier" && !target.droisoned) {
            targetDies = false;
          }
          if (monkSaved === target.seat) {
            targetDies = false;
          }

          // Mayor bounce
          if (target.role === "Mayor" && !target.droisoned && targetDies) {
            target.mayorAttackCount = target.mayorAttackCount || 0;
            target.mayorAttackCount++;

            const n = target.mayorAttackCount;
            // first time: always bounce. 2nd time: 33%. 3rd time, 25%. Nth time, 1/n%
            const protectionTriggers = n === 1 || percentTrue(100 / (n + 1));

            if (protectionTriggers) {
              targetDies = false;
              // Find a different good player to die instead
              const otherGoodPlayers = goodPlayers.filter(
                (p) => p.seat !== target.seat && p.alive
              );

              // Prioritize less useful roles for the bounce
              const lessUsefulRoles = [
                "Washerwoman",
                "Librarian",
                "Investigator",
                "Chef",
                "Ravenkeeper",
                "Slayer",
                "Saint",
                "Butler",
                "Recluse",
                "Drunk",
              ];

              // Filter to roles that qualify for the shortlist
              const shortlistVictims = otherGoodPlayers.filter((p) => {
                const role = p.role;
                if (!lessUsefulRoles.includes(role)) return false;

                // Additional conditions for specific roles
                if (role === "Ravenkeeper" && p.droisoned) return false;
                if (role === "Slayer" && !p.shotUsed) return false; // Only if ability is spent
                if (role === "Drunk" && p.appears_as.role === "Ravenkeeper")
                  return false; // Skip drunk appearing as RK

                return true;
              });

              let alternateVictim = null;

              // Try shortlist first, then all good players, then minions
              if (shortlistVictims.length > 0) {
                alternateVictim = getRandomItem(shortlistVictims);
              } else if (otherGoodPlayers.length > 0) {
                alternateVictim = getRandomItem(otherGoodPlayers);
              } else {
                // If no good players available, kill a random minion instead
                const minions = gameStatePlayers.filter(
                  (p) => p.alive && p.type === "minion"
                );
                if (minions.length > 0) {
                  alternateVictim = getRandomItem(minions);
                }
              }

              // Kill the alternate victim instead (if they can die)
              if (alternateVictim) {
                let alternateCanDie = true;

                // Check if alternate is a protected Soldier
                if (
                  alternateVictim.role === "Soldier" &&
                  !alternateVictim.droisoned
                ) {
                  alternateCanDie = false;
                }

                // Check if alternate is protected by Monk
                if (monkSaved === alternateVictim.seat) {
                  alternateCanDie = false;
                }

                if (alternateCanDie) {
                  const alternateToken =
                    circleContainer.children[alternateVictim.seat];
                  killPlayer(alternateToken, alternateVictim.seat, true);
                  deferredDeaths.push(alternateVictim.seat);
                  impKilledTonight = alternateVictim;
                }
              }
            }
          }

          if (targetDies) {
            const targetToken = circleContainer.children[target.seat];
            // Soldier/Mayor who die while poisoned: mark as poisonkilled
            if (
              (target.role === "Soldier" || target.role === "Mayor") &&
              target.droisoned
            ) {
              target.gameover_text = "I was Poisonkilled üß™";
            }
            killPlayer(targetToken, target.seat, true); // true = delay visual
            deferredDeaths.push(target.seat);
            impKilledTonight = target;
          }
        }

        const rk = getAppearAsRoleIfInPlay("Ravenkeeper");
        if (impKilledTonight && rk && rk.seat === impKilledTonight.seat) {
          // if ravenkeeper has no chosen target pick a random one from living ppl, not yourself.
          if (!rk.rkChosenTarget) {
            const livingPlayers = gameStatePlayers.filter(
              (p) => p.alive && p.seat !== rk.seat
            );
            rk.rkChosenTarget = getRandomItem(livingPlayers).seat;
          }
          const rkTarget = gameStatePlayers[rk.rkChosenTarget];

          const soberGoodRk = !rk.droisoned && !rk.evil;

          const trickedBySpy = rkTarget.role === "Spy" && percentTrue(50);
          const trickedByRecluse =
            rkTarget.role === "Recluse" && percentTrue(50);

          let seenRole;
          const seenPlayer = rkTarget.name;

          if (soberGoodRk && !trickedBySpy && !trickedByRecluse) {
            seenRole = rkTarget.role;
          } else {
            // learn an evil/Drunk player's bluff
            if (rkTarget.evil || rkTarget.role === "Drunk") {
              seenRole = rkTarget.appears_as.role;
            } else {
              // frame a good player as a random evil/drunk
              const possibleLies = ["Poisoner", "Scarlet Woman", "Imp", "Spy"];
              if (checkIsBaronPossible()) possibleLies.push("Baron");
              if (rkTarget.type === "Townsfolk") possibleLies.push("Drunk");
              seenRole = getRandomItem(possibleLies);
            }
          }
          rk.info_text = `${seenPlayer} ${seenRole}`;
          if (rk.role === "Ravenkeeper") {
            rk.gameover_text = rk.info_text;
            // If RK died on the same night they were poisoned, tag their info
            markPoisonedInfoIfApplicable(rk);
          }
        }

        // TODO: undertaker

        const undertaker = getAppearsAsIfAlive("Undertaker");
        if (undertaker && previousExecution) {
          // sober undertaker: see the role of the preivous executee
          const soberUndertaker = !undertaker.droisoned && !undertaker.evil;
          const droisonedUndertaker = undertaker.droisoned && !undertaker.evil;
          const evilUndertaker = undertaker.evil;

          let infotext = "Unimplemented";

          let learnRealInfo = false;
          let confirmEvilPlayer = false;
          let frameGoodPlayer = false;
          let learnRandomGarbage = false;

          if (soberUndertaker) {
            // sober undertaker can get trolled by recluse and spy, otherwise learn good info
            if (previousExecution.role === "Spy" && percentTrue(60)) {
              confirmEvilPlayer = true;
            } else if (
              previousExecution.role === "Recluse" &&
              percentTrue(60) &&
              !previousExecution.droisoned
            ) {
              frameGoodPlayer = true;
            } else {
              learnRealInfo = true;
            }
          } else if (droisonedUndertaker || (evilUndertaker && !evilHasGrim)) {
            // droisoned and evil spyless undertaker are the same thing
            // that way it gives more credibility to evil players who don't have a spy
            // TODO: random stuff here. confirm evil players, frame good players, or make random guesses on any player.
            //
            // however they might want to frame a fake invest ping as real.
            // they might want to frame a fake fortune teller yes as an imp.
            // they might want to support a fake empath's story.
            // complicated business around here for real.
            //
          } else if (evilUndertaker) {
            // if evil has a spy they can be a "real" undertaker except they can frame a few good players here and there
            // TODO: this
            // an undertaker with a spy sees info and can corraborate stories, real or fake
          }

          if (learnRealInfo) {
            infotext = `${previousExecution.name} ${previousExecution.role}`;
            appendPreviousInfo(undertaker, previousExecution.role);
          } else if (confirmEvilPlayer) {
            infotext = `${previousExecution.name} ${previousExecution.appears_as.role}`;
            appendPreviousInfo(undertaker, previousExecution.appears_as.role);
          } else if (frameGoodPlayer) {
            // TODO: draw from a pool of evil roles, you could repeat something you saw. but make it less likely? idk.
            // you can learn imp only one time,,, hmm
            // TODO: the bluffs here are complicated and contextual lets do other stuff first...??????
            //
            // "evil pool" contains Drunk if they are a townsfolk,
            // it includes Baron if baron is possible.
          } else if (learnRandomGarbage) {
            // learn a random role you haven't learned yet! but not undertaker.
            // TODO: this as well
          }

          // recluse could be evil; spy could be good
          // if no execution, always empty string
          // poisoned: see Drunk, garbage, evil role... maybe true info on a good player but not an evil one for sure.
          // evil: see allies as good.
          // if spy in play, can confirm good ppl. can also frame people as evil.
          appendInfoText(undertaker, infotext);
          if (!evilUndertaker) {
            undertaker.gameover_text = undertaker.info_text;
          }
        }
        // empath
        const empath = getAppearsAsIfAlive("Empath");
        if (empath) {
          const { left, right } = getLivingNeighbors(empath.seat);
          const n1 = gameStatePlayers[left];
          const n2 = gameStatePlayers[right];

          // Update frame map each night:
          // - if a target in frame_map died (impKilledTonight), replace with new living person
          // - if all targets are dead, add a new random person
          if (empath.frame_map) {
            const aliveInFrameMap = empath.frame_map.filter(
              (seat) => gameStatePlayers[seat] && gameStatePlayers[seat].alive
            );

            // Check if impKilledTonight is in the frame map
            const impKilledInMap =
              impKilledTonight &&
              empath.frame_map.includes(impKilledTonight.seat);

            if (impKilledInMap || aliveInFrameMap.length === 0) {
              // Need to add/replace someone in the frame map
              const impOrSw = (player) =>
                player &&
                (player.role === "Imp" || player.role === "Scarlet Woman");
              const imp = getRoleIfInPlay("Imp");
              const sw = getRoleIfInPlay("Scarlet Woman");

              // Build exclusion set: empath, imp, SW, and current living frame map members
              const excludedSeats = new Set([empath.seat]);
              if (imp) excludedSeats.add(imp.seat);
              if (sw) excludedSeats.add(sw.seat);
              aliveInFrameMap.forEach((seat) => excludedSeats.add(seat));

              // Build candidate pool
              const candidates = gameStatePlayers.filter(
                (p) => !excludedSeats.has(p.seat) && p.alive
              );

              if (candidates.length > 0) {
                // Add a new person to the frame map
                const newPerson = getRandomItem(candidates);
                empath.frame_map.push(newPerson.seat);
              } else {
                // Only options are Imp, empath, and SW: can add the SW
                if (sw && sw.alive && !empath.frame_map.includes(sw.seat)) {
                  empath.frame_map.push(sw.seat);
                }
              }
            }
          }

          const soberEmpath = !empath.droisoned && !empath.evil;
          const evilEmpath = empath.evil;
          const droisonedEmpath = empath.droisoned && !empath.evil;

          let learnedNumber = 0;
          const frameMap = empath.frame_map || [];

          // sober+good empath gets true info, might misregister on recluse/spy
          if (soberEmpath) {
            [n1, n2].forEach((player) => {
              if (
                player &&
                (player.evil ||
                  (player.role === "Recluse" && empath.recluseEvil) ||
                  (player.role === "Spy" && empath.spyEvil))
              )
                learnedNumber++;
            });
          } else if (droisonedEmpath || evilEmpath) {
            // drunk/evil empath uses frame map to determine reported number
            learnedNumber = [n1, n2].reduce(
              (acc, player) =>
                acc + (player && frameMap.includes(player.seat) ? 1 : 0),
              0
            );
          }

          const leftName = n1 ? n1.name : "None";
          const rightName = n2 ? n2.name : "None";
          appendInfoText(
            empath,
            `${leftName}/${rightName} ${learnedNumber}`,
            !!empath.droisoned
          );
          if (!empath.evil) {
            rebuildGameoverFromInfoLog(empath);
          }
        }
        // Fortune Teller nightly checks: process chosen targets (if any) or pick randomly

        // TODO: a fortune teller who picks randomly will never randomly pick the person who died tonight to the imp.
        const ft = getAppearsAsIfAlive("Fortune Teller");
        if (ft) {
          // Remove pending notation before processing night result
          if (ft.info_text && ft.info_text.includes(", (")) {
            ft.info_text = ft.info_text.replace(/, \([^)]+\)/, "");
          }

          // determine targets: use chosen targets if provided, otherwise pick 2 random alive players
          let targets = [];
          if (ft.ftChosenTargets && ft.ftChosenTargets.length === 2) {
            targets = ft.ftChosenTargets.map((s) => gameStatePlayers[s]);
          } else {
            const alivePlayers = gameStatePlayers.filter((p) => p.alive);
            const picks = getRandomItems(
              alivePlayers,
              Math.min(2, alivePlayers.length)
            ).selected;
            targets = picks;
          }
          const x = targets[0];
          const y = targets[1] || targets[0];

          function setFTResultFt(res) {
            appendInfoText(
              ft,
              `${x.name}/${y.name} ${res ? "Yes" : "No"}`,
              !!ft.droisoned
            );
            if (!ft.evil) rebuildGameoverFromInfoLog(ft);
          }

          const realFT = ft.role === "Fortune Teller";
          if (realFT && !ft.droisoned && !ft.evil) {
            const eitherIsDemon = x.role === "Imp" || y.role === "Imp";
            const eitherIsRedHerring =
              x.seat === ft.red_herring || y.seat === ft.red_herring;
            const recluseTrigger =
              (x.role === "Recluse" || y.role === "Recluse") && percentTrue(75);
            if (eitherIsDemon || eitherIsRedHerring || recluseTrigger)
              setFTResultFt(true);
            else setFTResultFt(false);
          } else {
            const inFrame =
              ft.frame_map &&
              (ft.frame_map.includes(x.seat) || ft.frame_map.includes(y.seat));
            setFTResultFt(!!inFrame);
          }

          // clear chosen targets so the player must pick again for the next night
          ft.ftChosenTargets = null;
          if (ft.alive) ft.actionmodeText = "Who should I check tonight?";
        }

        // Check for all evil win or demon win conditions
        if (checkGameEndConditions()) {
          return;
        }
      }

      function generateAndDisplayScript() {
        evilHasGrim = false;
        previousExecution = null;
        gameEnded = false;
        killModeToggleBtn.disabled = false;
        // action mode should be re-enabled for a new game
        // reset action-mode state when a new game is started
        isActionMode = false;
        currentActor = null;
        // make sure any visual active classes are cleared from body/container
        document.body.classList.toggle("action-mode-active", false);
        container.classList.toggle("action-mode-active", false);
        isKillMode = false;
        document.body.classList.remove("kill-mode-active");
        container.classList.remove("kill-mode-active");
        killModeToggleBtn.textContent = "Execute Mode: OFF";
        currentPhase = "day";
        canExecutePlayer = true;
        deferredDeaths = [];
        phaseDisplay.classList.remove("good-wins", "evil-wins");

        setupCenterButton(null, null, false);
        const playerCount = parseInt(playerCountSelect.value, 10);
        let counts = { ...playerCounts[playerCount] };
        const baseOutsiderCount = counts.outsiders;

        // --- SCRIPT GENERATION ---
        // generate demon (its imp!)
        const selectedDemons = getRandomItems(
          characters.demons,
          counts.demons
        ).selected;
        // generate minions
        const selectedMinions = getRandomItems(
          characters.minions,
          counts.minions
        ).selected;
        const isBaronInPlay = selectedMinions.some(
          (minion) => minion.name === "Baron"
        );

        if (isBaronInPlay) {
          counts.townsfolk -= 2;
          counts.outsiders += 2;
        }
        const spyInPlay = selectedMinions.some(
          (minion) => minion.name === "Spy"
        );
        evilHasGrim = spyInPlay;
        // generate outsiders
        const outsiderRNG = getRandomItems(
          characters.outsiders,
          counts.outsiders
        );
        const selectedOutsiders = outsiderRNG.selected;
        const notInPlayOutsiders = outsiderRNG.notSelected;

        const townsfolkRNG = getRandomItems(
          characters.townsfolk,
          counts.townsfolk
        );
        const selectedTownsfolk = townsfolkRNG.selected;
        const notInPlayTownsfolk = townsfolkRNG.notSelected;

        const faceUpOutsiders = selectedOutsiders.filter(
          (item) => item.name !== "Drunk"
        ).length;

        // calculate correct number of outsider bluffs that can be given
        let maxOutsiderBluffs = baseOutsiderCount + 2 - faceUpOutsiders;

        const bluffableOutsiders = notInPlayOutsiders
          .filter((item) => item.name !== "Drunk")
          .slice(0, maxOutsiderBluffs);

        // if there is a drunk, pop one item from notinplaytownsfolk
        const isDrunkInPlay =
          selectedOutsiders.findIndex((o) => o.name === "Drunk") > -1;
        const designatedDrunkBluff = isDrunkInPlay
          ? notInPlayTownsfolk.pop()
          : null;

        const bluffRNG = getRandomItems(
          [...bluffableOutsiders, ...notInPlayTownsfolk],
          3
        );
        const demonBluffs = bluffRNG.selected;
        const unusedBluffs = bluffRNG.notSelected;

        if (selectedMinions.length === 3) {
          // i would have to rework a lot of code to make double claims work so honestly nah.
          // BOTC as a whole is not balanced around one person having all the info anyways
          // so i see this as acceptable for this game.
          demonBluffs.push(unusedBluffs[0]);
        }
        const ingamePlayers = shuffleArray(playerNames.slice(0, playerCount));

        const shuffledTokens = shuffleArray([
          ...selectedDemons,
          ...selectedMinions,
          ...selectedOutsiders,
          ...selectedTownsfolk,
        ]);

        // collect all the tokens and then turn them into players
        let demonBluffIndex = 0;
        gameStatePlayers = [];
        for (let i = 0; i < shuffledTokens.length; i++) {
          // minions/demons each get a bluff
          const token = shuffledTokens[i];
          let appears_as = { role: token.name, type: token.type };
          let gameover_text = "";
          if (token.type === "minion" || token.type === "demon") {
            appears_as = {
              role: demonBluffs[demonBluffIndex].name,
              type: demonBluffs[demonBluffIndex].type,
            };
            gameover_text = `I was the ${token.name} bluffing ${appears_as.role}`;
            demonBluffIndex++;
          }
          if (token.name === "Drunk") {
            appears_as = {
              role: designatedDrunkBluff.name,
              type: designatedDrunkBluff.type,
            };
            gameover_text = `I saw myself as ${designatedDrunkBluff.name}`;
          }
          const player = {
            seat: i,
            name: ingamePlayers[i],
            role: token.name,
            type: token.type,
            evil: token.evil,
            alive: true,
            appears_as,
            info_text: "",
            // For action mode (slayer-like one-shot day actions)
            // default is null and will fall back to info_text if null
            actionmodeText: null,
            // whether this player has used their one-shot action
            shotUsed: false,
            droisoned: token.name === "Drunk",
            // Poisoner-specific state: track last night's target
            previousPoisonTarget: null,
            gameover_text,
          };
          gameStatePlayers.push(player);
          // Slayer and players who appear as Slayer (drunk bluffs or evil bluffs) should be able to shoot (one-shot day action)
          if (player.role === "Slayer" || player.appears_as.role === "Slayer") {
            player.actionmodeText = "I can shoot";
          }
          // Virgin: a one-shot nomination ability
          if (player.role === "Virgin" || player.appears_as.role === "Virgin") {
            player.actionmodeText = "Has Ability";
          }
          // Fortune Teller: nightly check selector (select two players during day for night checks)
          if (
            player.role === "Fortune Teller" ||
            player.appears_as.role === "Fortune Teller"
          ) {
            player.actionmodeText = "Who do I check tonight?";
            // chosen targets for the upcoming night (set by player during the day)
            player.ftChosenTargets = null;
          }
          // Monk: single target protection selector (select one player during day for that night's protection)
          if (player.role === "Monk" || player.appears_as.role === "Monk") {
            player.actionmodeText = "Who should I protect tonight?";
            // chosen target for the upcoming night's protection (set by player during the day)
            player.monkChosenTarget = null;
          }
          // Ravenkeeper: single target info selector (learn role of chosen player on death)
          if (
            player.role === "Ravenkeeper" ||
            player.appears_as.role === "Ravenkeeper"
          ) {
            player.actionmodeText = "Who should I check tonight?";
            // chosen target for the upcoming night's check (set by player during the day)
            player.rkChosenTarget = null;
          }
          // Mayor: track number of times attacked by Imp at night
          if (player.role === "Mayor") {
            player.mayorAttackCount = 0;
          }
        }

        night1();
        phaseNumber = 1;
        updatePhaseDisplay();
        displayPlayerCircle(false);
      }

      function displayPlayerCircle(grim_reveal = false) {
        circleContainer.innerHTML = "";
        const playerCount = gameStatePlayers.length;
        console.log(gameStatePlayers); // TODO: debug mode
        const radius = circleContainer.offsetWidth / 2 - 70; // 70 is a magic number for spacing

        for (let i = 0; i < playerCount; i++) {
          const player = gameStatePlayers[i];
          const angle = (i / playerCount) * 360;
          const angleRad = angle * (Math.PI / 180);

          const x = radius * Math.cos(angleRad);
          const y = radius * Math.sin(angleRad);

          const role = grim_reveal ? player : player.appears_as;
          const playerName = player.name;

          const tokenEl = document.createElement("div");
          // highlight players who have an unspent action (always show lightning badge)
          const hasUnspentAction =
            !grim_reveal &&
            player.alive &&
            player.actionmodeText != null &&
            !player.shotUsed &&
            // Fortune Teller who already has chosen targets for tonight should not show the badge
            !(player.ftChosenTargets && player.ftChosenTargets.length === 2) &&
            // Monk who already has chosen a target for tonight should not show the badge
            !(
              player.monkChosenTarget !== null &&
              player.monkChosenTarget !== undefined
            ) &&
            // Ravenkeeper who already has chosen a target for tonight should not show the badge
            !(
              player.rkChosenTarget !== null &&
              player.rkChosenTarget !== undefined
            );
          // actionReady is specifically for animation during action mode
          const actionReady = isActionMode && hasUnspentAction;
          tokenEl.className = `player-token ${role.type} ${
            player.alive ? "" : "dead"
          }${hasUnspentAction ? " action-ready" : ""}`;

          // expose the appears-as role on the DOM node for CSS targeting (e.g. Fortune Teller badge)
          tokenEl.setAttribute("data-role", role.role);

          // The transform places the element around the circle. The final rotate(-angle) keeps the text upright.
          tokenEl.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg) translate(60px) rotate(-${angle}deg)`;

          let speech = "";

          if (grim_reveal) {
            speech = player.gameover_text || "";
          } else if (isActionMode) {
            // Action mode display rules: show actionmodeText if present and player is alive; otherwise fall back to standard info_text
            // If this player is currently selected as the actor, show the selection prompt
            if (currentActor !== null && currentActor === i) {
              const actingPlayer = gameStatePlayers[currentActor];
              const seenRole = actingPlayer.appears_as.role;
              if (seenRole === "Slayer") speech = "Who to shoot?";
              else if (seenRole === "Virgin") speech = "Who nominates me?";
              else if (seenRole === "Fortune Teller")
                speech = "Pick two players";
              else if (seenRole === "Monk") speech = "Who to protect?";
              else if (seenRole === "Ravenkeeper") speech = "Who to check?";
              else speech = "Who to pick?";
              // ensure center button shows cancel while a actor is selected
              setupCenterButton("Cancel");
            } else {
              // prefer actionmodeText (if player is alive and action not used), then fallback to  info_text
              speech = player.info_text || "";
            }
          } else {
            speech = player.info_text || "";
          }

          // Add warning if Ravenkeeper (real or fake) chose a dead target
          const rkSeesAsRavenkeeper =
            player.role === "Ravenkeeper" ||
            player.appears_as.role === "Ravenkeeper";
          const rkTarget =
            player.rkChosenTarget !== null &&
            player.rkChosenTarget !== undefined
              ? gameStatePlayers[player.rkChosenTarget]
              : null;
          if (
            rkSeesAsRavenkeeper &&
            rkTarget &&
            !rkTarget.alive &&
            !grim_reveal
          ) {
            speech += " ‚ÅâÔ∏è";
          }

          // Add warning if living Monk (real or fake) is protecting a dead player
          const monkSeesAsMonk =
            player.role === "Monk" || player.appears_as.role === "Monk";
          const monkTarget =
            player.monkChosenTarget !== null &&
            player.monkChosenTarget !== undefined
              ? gameStatePlayers[player.monkChosenTarget]
              : null;
          if (
            monkSeesAsMonk &&
            player.alive &&
            monkTarget &&
            !monkTarget.alive &&
            !grim_reveal
          ) {
            speech += " ‚ÅâÔ∏è";
          }

          tokenEl.innerHTML = `
                    <div class="speech-bubble${
                      speech ? " visible" : ""
                    }">${speech}</div>
                    <strong>${playerName}</strong>
                    <span>${role.role}</span>
                  `;
          // Add a click listener to toggle the 'dead' class on the token.
          // This allows you to mark players as executed.
          tokenEl.addEventListener("click", () => {
            const clicked = gameStatePlayers[i];

            // kill mode click
            if (isKillMode) {
              executePlayer(tokenEl, i);
              return;
            }

            // if not in kill mode or action mode, and this player has an action,
            // auto-activate action mode and select them (but only during day and game hasn't ended)
            if (
              !isActionMode &&
              !isKillMode &&
              currentPhase === "day" &&
              !gameEnded
            ) {
              if (
                clicked.alive &&
                clicked.actionmodeText &&
                !clicked.shotUsed
              ) {
                // enable action mode
                isActionMode = true;
                document.body.classList.toggle("action-mode-active", true);
                container.classList.toggle("action-mode-active", true);
                // select this player
                currentActor = i;
                setupCenterButton("Cancel");
                displayPlayerCircle(false);
                return;
              }
            }

            // action mode click
            if (isActionMode) {
              // only during day
              if (currentPhase !== "day") return;

              // if we don't currently have a actor selected, clicking a actor selects them
              if (currentActor === null) {
                if (
                  clicked.actionmodeText &&
                  !clicked.shotUsed &&
                  clicked.alive
                ) {
                  currentActor = i;
                  // show cancel button
                  setupCenterButton("Cancel");
                  displayPlayerCircle(false);
                }
                return;
              }

              // if a actor is selected and we click another player, that is the target
              if (currentActor !== null) {
                const actor = gameStatePlayers[currentActor];
                // decide which action to run based on the actor's apparent role
                // Slayer: single target kill-like behavior
                if (
                  actor.appears_as.role === "Slayer" ||
                  actor.role === "Slayer"
                ) {
                  // clicking the actor again is a no-op for Slayer
                  if (currentActor === i) return;
                  // Slayer can only target alive players
                  if (!clicked.alive) return;
                  const ended = slayerShoot(currentActor, i);
                  if (!ended) {
                    currentActor = null;
                    setupCenterButton(null, null, false);
                    displayPlayerCircle(false);
                  }
                }
                // Virgin: single-target nominate behavior
                else if (
                  actor.appears_as.role === "Virgin" ||
                  actor.role === "Virgin"
                ) {
                  // clicking the actor again is a no-op for Virgin
                  if (currentActor === i) return;
                  // Virgin can only target alive players
                  if (!clicked.alive) return;
                  const ended = virginNominate(currentActor, i);
                  if (!ended) {
                    currentActor = null;
                    setupCenterButton(null, null, false);
                    displayPlayerCircle(false);
                  }
                }
                // Fortune Teller: select two different targets during the day to set up the night's check
                // Fortune Teller CAN check dead players
                else if (
                  actor.appears_as.role === "Fortune Teller" ||
                  actor.role === "Fortune Teller"
                ) {
                  // Check if this click is a change to existing choice
                  if (
                    actor.ftChosenTargets &&
                    actor.ftChosenTargets.length === 2
                  ) {
                    // Clear the old choice and start fresh
                    actor.ftChosenTargets = null;
                    actor.ftPending = [];
                    // Remove the pending notation from info_text
                    if (actor.info_text && actor.info_text.includes(", (")) {
                      actor.info_text = actor.info_text.replace(
                        /, \([^)]+\)/,
                        ""
                      );
                    }
                  } else {
                    // initialize pending selection store
                    if (!actor.ftPending) actor.ftPending = [];
                  }

                  // ignore duplicate picks
                  if (actor.ftPending.includes(i)) return;
                  actor.ftPending.push(i);

                  // if we now have two picks, commit them
                  if (actor.ftPending.length === 2) {
                    actor.ftChosenTargets = [...actor.ftPending];
                    const a = gameStatePlayers[actor.ftChosenTargets[0]].name;
                    const b = gameStatePlayers[actor.ftChosenTargets[1]].name;
                    actor.actionmodeText = `Checking ${a}/${b}`;
                    // Add pending notation to info_text
                    if (!actor.info_text) {
                      actor.info_text = `(${a}/${b})`;
                    } else {
                      actor.info_text += `, (${a}/${b})`;
                    }
                    actor.ftPending = null;
                    // exit action mode after committing the two picks
                    currentActor = null;
                    if (isActionMode) {
                      isActionMode = false;
                      document.body.classList.toggle(
                        "action-mode-active",
                        false
                      );
                      container.classList.toggle("action-mode-active", false);
                    }
                    setupCenterButton(null, null, false);
                    displayPlayerCircle(false);
                  } else {
                    // need a second pick, keep actor selected
                    displayPlayerCircle(false);
                  }
                }
                // Monk: single target protection selection
                else if (
                  actor.appears_as.role === "Monk" ||
                  actor.role === "Monk"
                ) {
                  // clicking the actor again is a change to existing choice
                  if (currentActor === i) return;

                  // Check if this click is a change to existing choice
                  if (
                    actor.monkChosenTarget !== null &&
                    actor.monkChosenTarget !== undefined
                  ) {
                    // Clear the old choice and remove pending notation from info_text
                    if (actor.info_text && actor.info_text.includes("(")) {
                      actor.info_text = actor.info_text
                        .replace(/, \([^)]+\)$/, "")
                        .replace(/\([^)]+\)$/, "");
                    }
                    actor.monkChosenTarget = null;
                  }

                  const monkTarget = gameStatePlayers[i].name;
                  actor.monkChosenTarget = i;
                  actor.actionmodeText = `Protecting ${monkTarget}`;
                  // Add pending notation to info_text
                  if (!actor.info_text) {
                    actor.info_text = `(${monkTarget})`;
                  } else {
                    actor.info_text += `, (${monkTarget})`;
                  }
                  // exit action mode after committing the pick
                  currentActor = null;
                  if (isActionMode) {
                    isActionMode = false;
                    document.body.classList.toggle("action-mode-active", false);
                    container.classList.toggle("action-mode-active", false);
                  }
                  setupCenterButton(null, null, false);
                  displayPlayerCircle(false);
                }
                // Ravenkeeper: single target info selection
                else if (
                  actor.appears_as.role === "Ravenkeeper" ||
                  actor.role === "Ravenkeeper"
                ) {
                  // clicking the actor again is a change to existing choice
                  if (currentActor === i) return;

                  // Remove any existing pending notation from info_text (Ravenkeeper only tracks one target at a time)
                  if (actor.info_text && actor.info_text.includes("(")) {
                    actor.info_text = actor.info_text
                      .replace(/, \([^)]+\)$/, "")
                      .replace(/\([^)]+\)$/, "");
                  }

                  const rkTarget = gameStatePlayers[i].name;
                  actor.rkChosenTarget = i;
                  actor.actionmodeText = `Checking ${rkTarget}`;
                  // Add pending notation to info_text
                  if (!actor.info_text) {
                    actor.info_text = `(${rkTarget})`;
                  } else {
                    actor.info_text += `, (${rkTarget})`;
                  }
                  // exit action mode after committing the pick
                  currentActor = null;
                  if (isActionMode) {
                    isActionMode = false;
                    document.body.classList.toggle("action-mode-active", false);
                    container.classList.toggle("action-mode-active", false);
                  }
                  setupCenterButton(null, null, false);
                  displayPlayerCircle(false);
                }
              }
              return;
            }
            // otherwise clicking does nothing for now
          });

          circleContainer.appendChild(tokenEl);
        }
      }

      function endGame(goodWon) {
        gameEnded = true;
        isKillMode = false;
        document.body.classList.remove("kill-mode-active");
        container.classList.remove("kill-mode-active");
        killModeToggleBtn.textContent = "Execute Mode: OFF";

        killModeToggleBtn.disabled = true;

        phaseDisplay.classList.remove("good-wins", "evil-wins");
        phaseDisplay.textContent = goodWon ? "GOOD WIN" : "EVIL WIN";
        phaseDisplay.classList.add(goodWon ? "good-wins" : "evil-wins");

        setupCenterButton(null, null, false);

        canExecutePlayer = false;

        // clear any lingering action-mode state so grim reveal looks correct
        if (isActionMode) {
          isActionMode = false;
          currentActor = null;
          document.body.classList.remove("action-mode-active");
          container.classList.remove("action-mode-active");
        }

        displayPlayerCircle(true); // grim reveal
      }

      // ----- GOOD for some nice RNG  ----
      // function main() {
      //   for (let i = 0; i < 40000; i++) {
      //     generateAndDisplayScript();
      //     x[
      //       countEvilPairs(gameStatePlayers, flipCoin(), flipCoin())
      //     ]++;
      //   }
      //   console.log(x);
      // }

      document.addEventListener("DOMContentLoaded", generateAndDisplayScript);
      generateBtn.addEventListener("click", generateAndDisplayScript);
      centerActionButton.addEventListener("click", () => {
        if (typeof currentCenterAction === "function") {
          currentCenterAction(); // Execute the stored function
        }
      });
    </script>
  </body>
</html>
