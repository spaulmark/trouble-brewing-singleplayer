<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Single Player Trouble Brewing</title>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --primary-color: #a02c2c;
        --card-bg: #2c2c2c;
        --border-color: #444;
        --townsfolk-color: #2e86c1;
        --outsider-color: #85c1e9;
        --minion-color: #e74c3c;
        --demon-color: #c0392b;
      }
      #center-action-btn {
        position: absolute;
        top: 65%; /* Position it below the DAY/NIGHT text */
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20; /* Make sure it's on top */

        padding: 10px 20px;
        font-size: 1.1em;
        font-weight: bold;
        background-color: #555;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;

        /* For the fade-in/out effect */
        visibility: hidden;
        opacity: 0;
      }

      #center-action-btn:hover {
        background-color: #666;
        border-color: #777;
      }

      /* A class to make the button visible */
      #center-action-btn.visible {
        visibility: visible;
        opacity: 1;
      }
      #kill-mode-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        font-size: 1em;
        font-weight: bold;
        background-color: #333;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        z-index: 1000;
        transition: background-color 0.3s, color 0.3s;
      }

      body.kill-mode-active #kill-mode-toggle {
        background-color: var(--primary-color);
        color: white;
        border-color: #c0392b;
      }

      body {
        transition: background-color 0.4s ease;
      }

      body.kill-mode-active {
        background-color: #2a1a1a;
      }

      .container.kill-mode-active {
        background-color: rgb(70, 40, 40);
        transition: background-color 0.3s, color 0.3s;
      }

      /* Change cursor to crosshair on tokens ONLY when in kill mode */
      body.kill-mode-active .player-token {
        cursor: crosshair;
      }

      .player-token {
        position: relative;
      }

      .speech-bubble {
        pointer-events: none;
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 10px;

        background-color: #e0e0e0;
        color: #1a1a1a;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        width: 140px;

        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .speech-bubble::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 8px;
        border-style: solid;
        border-color: #e0e0e0 transparent transparent transparent;
      }

      .speech-bubble.visible {
        visibility: visible;
        opacity: 1;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s, color 0.3s;
      }

      h1,
      h2,
      h3 {
        text-align: center;
        color: var(--primary-color);
        text-transform: uppercase;
        letter-spacing: 2px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 10px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 30px;
      }

      .controls label {
        font-size: 1.1em;
        font-weight: bold;
      }

      #player-count,
      #generate-btn {
        padding: 10px 15px;
        font-size: 1em;
        border-radius: 5px;
        border: 1px solid var(--border-color);
        background-color: #333;
        color: var(--text-color);
        cursor: pointer;
      }

      #generate-btn {
        background-color: var(--primary-color);
        color: white;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }

      #generate-btn:hover {
        background-color: #c0392b;
      }

      .script-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
        visibility: hidden;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li {
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
      }
      li strong {
        display: inline;
        font-size: 1.1em;
        color: #fff;
      }
      li .ability {
        display: block;
        margin-top: 5px;
      }
      .drunk-marker {
        font-weight: bold;
        font-style: italic;
        color: var(--outsider-color);
        margin-left: 8px;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      #phase-display {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        user-select: none;

        font-size: 7em;
        font-weight: bold;
        color: rgba(224, 224, 224, 0.1);
        text-transform: uppercase;
        letter-spacing: 5px;
        text-align: center;
        pointer-events: none;
        z-index: 10;
      }
      #phase-display.good-wins {
        color: var(--townsfolk-color);
        opacity: 1;
      }
      #phase-display.evil-wins {
        color: var(--demon-color);
        opacity: 1;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      .circle-container {
        position: relative;
        width: 725px;
        height: 725px;
        margin: 100px auto 40px;
        border: 2px dashed var(--border-color);
        border-radius: 50%;
      }

      .player-token {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 120px;
        height: 60px;
        margin: -30px 0 0 -60px;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;

        border: 3px solid yellow;
        border-radius: 8px;
        background-color: var(--card-bg);
        font-size: 0.9em;

        transition: opacity 0.1s ease;
        user-select: none;

        transition: box-shadow 0.1s ease-out, transform 0.1s ease-out;
        will-change: transform, box-shadow;
      }

      .player-token.townsfolk:hover {
        box-shadow: 0 0 15px 3px var(--townsfolk-color);
      }
      .player-token.outsider:hover {
        box-shadow: 0 0 15px 3px var(--outsider-color);
      }
      .player-token.minion:hover {
        box-shadow: 0 0 15px 3px var(--minion-color);
      }
      .player-token.demon:hover {
        box-shadow: 0 0 15px 3px var(--demon-color);
      }

      /* dead ppl dont glow */
      .player-token.dead:hover {
        transform: none;
        box-shadow: none;
        cursor: not-allowed;
      }

      /* Style for dead players */
      .player-token.dead {
        opacity: 0.4;
      }
      .player-token.dead strong,
      .player-token.dead span {
        text-decoration: line-through;
      }

      .player-token strong {
        font-size: 1.1em;
        color: var(--text-color);
      }
      .player-token span {
        font-weight: bold;
      }

      /* Color coding the tokens by role type */
      .player-token.townsfolk {
        border-color: var(--townsfolk-color);
      }
      .player-token.townsfolk span {
        color: var(--townsfolk-color);
      }

      .player-token.outsider {
        border-color: var(--outsider-color);
      }
      .player-token.outsider span {
        color: var(--outsider-color);
      }

      .player-token.minion {
        border-color: var(--minion-color);
      }
      .player-token.minion span {
        color: var(--minion-color);
      }

      .player-token.demon {
        border-color: var(--demon-color);
      }
      .player-token.demon span {
        color: var(--demon-color);
      }
    </style>
  </head>
  <body>
    <div class="container" id="container">
      <div class="controls">
        <label for="player-count">Select Player Count:</label>
        <select id="player-count">
          <option value="7">7 Players</option>
          <option value="8">8 Players</option>
          <option value="9">9 Players</option>
          <option value="10">10 Players</option>
          <option value="11">11 Players</option>
          <option value="12" selected>12 Players</option>
          <option value="13">13 Players</option>
          <option value="14">14 Players</option>
          <option value="15">15 Players</option>
        </select>
        <button id="generate-btn">New Game</button>
      </div>
      <div id="player-assignments">
        <div id="phase-display"></div>
        <button id="center-action-btn"></button>
        <div class="circle-container" id="circle-container">
          <!-- players appear here -->
        </div>
        <button id="kill-mode-toggle">Execute Mode: OFF</button>
      </div>
    </div>

    <script>
      // --- DATA ---
      const characters = {
        townsfolk: [
          {
            name: "Washerwoman",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Librarian",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Investigator",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Chef",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Empath",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Fortune Teller",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Undertaker",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Monk",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Ravenkeeper",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Virgin",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Slayer",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Soldier",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Mayor",
            type: "townsfolk",
            evil: false,
          },
        ],
        outsiders: [
          {
            name: "Butler",
            type: "outsider",
            evil: false,
          },
          {
            name: "Drunk",
            type: "outsider",
            evil: false,
          },
          {
            name: "Recluse",
            type: "outsider",
            evil: false,
          },
          {
            name: "Saint",
            type: "outsider",
            evil: false,
          },
        ],
        minions: [
          {
            name: "Poisoner",
            type: "minion",
            evil: true,
          },
          {
            name: "Spy",
            type: "minion",
            evil: true,
          },
          {
            name: "Scarlet Woman",
            type: "minion",
            evil: true,
          },
          {
            name: "Baron",
            type: "minion",
            evil: true,
          },
        ],
        demons: [
          {
            name: "Imp",
            type: "demon",
            evil: true,
          },
        ],
      };

      const playerCounts = {
        7: { townsfolk: 5, outsiders: 0, minions: 1, demons: 1 },
        8: { townsfolk: 5, outsiders: 1, minions: 1, demons: 1 },
        9: { townsfolk: 5, outsiders: 2, minions: 1, demons: 1 },
        10: { townsfolk: 7, outsiders: 0, minions: 2, demons: 1 },
        11: { townsfolk: 7, outsiders: 1, minions: 2, demons: 1 },
        12: { townsfolk: 7, outsiders: 2, minions: 2, demons: 1 },
        13: { townsfolk: 9, outsiders: 0, minions: 3, demons: 1 },
        14: { townsfolk: 9, outsiders: 1, minions: 3, demons: 1 },
        15: { townsfolk: 9, outsiders: 2, minions: 3, demons: 1 },
      };

      const playerNames = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
      ];

      // --- Ugly Number Data ---
      const chefNumbers = {
        7: [27112, 12350, 538, 0, 0, 0],
        8: [26668, 12319, 1013, 0, 0, 0],
        9: [26484, 12371, 1145, 0, 0, 0],
        10: [18741, 17440, 3617, 202, 0, 0],
        11: [18805, 16849, 4081, 265, 0, 0],
        12: [18988, 16524, 4198, 290, 0, 0],
        13: [12975, 18240, 7589, 1154, 42, 0],
        14: [13158, 18012, 7590, 1185, 55, 0],
        15: [13333, 17744, 7654, 1216, 53, 0],
      };

      // --- Dom Elements ---
      const playerCountSelect = document.getElementById("player-count");
      const generateBtn = document.getElementById("generate-btn");
      const circleContainer = document.getElementById("circle-container");
      const container = document.getElementById("container");
      const phaseDisplay = document.getElementById("phase-display");
      const centerActionButton = document.getElementById("center-action-btn");
      const killModeToggleBtn = document.getElementById("kill-mode-toggle");

      // magic numbers
      let nightPhaseMS = 1500;

      // game state variables
      let evilHasGrim = false;
      let currentPhase = "day";
      let phaseNumber = 1;
      let previousExecution = null;
      let gameStatePlayers = [
        /*{
        seat: 0,
        name: "ABCDEFG"
        character:  "drunk",
        type: "outsider"
        evil: true/false     // only 2 alignments in botc
        alive: true/false
        appears_as: {role: "mayor", type: "townsfolk"}
        my_info_text: "A/B yes, C/D no",
        gameover_text: "i saw myself as mayor",
        droisoned: true/false
        previous_info: [] // some array of useful info for me...?
      }*/
      ];
      /*
      role template:
      fortune teller: {
      default_choicebubble: "Who should I pick tonight?"
      }
      */

      // ui state variables
      let currentCenterAction = null;
      let canExecutePlayer = true;
      let isKillMode = false;

      function toggleKillModeBtn() {
        isKillMode = !isKillMode;
        document.body.classList.toggle("kill-mode-active", isKillMode);
        container.classList.toggle("kill-mode-active", isKillMode);

        if (isKillMode) {
          killModeToggleBtn.textContent = "Execute Mode: ON";
          // If it's daytime, show the "No Execution" button
          if (currentPhase === "day") {
            setupCenterButton("No Execution", () => executePlayer(null, -1));
          }
        } else {
          killModeToggleBtn.textContent = "Execute Mode: OFF";
          // Always hide the button when not in kill mode
          setupCenterButton(null, null, false);
        }
      }

      killModeToggleBtn.addEventListener("click", () => toggleKillModeBtn());

      function updatePhaseDisplay() {
        if (phaseDisplay) {
          // Check that the element exists
          phaseDisplay.textContent = `${currentPhase.toUpperCase()} ${phaseNumber}`;
        }
      }

      // --- UI Logic ---

      function setupCenterButton(text, action, isVisible = true) {
        if (isVisible) {
          centerActionButton.textContent = text;
          currentCenterAction = action; // Assign the function to our variable
          centerActionButton.classList.add("visible");
        } else {
          centerActionButton.classList.remove("visible");
          currentCenterAction = null; // Clear the action
        }
      }

      // --- GAME LOGIC ---
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function getRandomItems(array, numItems) {
        const shuffled = shuffleArray([...array]);
        const selected = shuffled.slice(0, numItems);
        const notSelected = shuffled.slice(numItems);
        return { selected, notSelected };
      }
      function getRandomItem(array) {
        return getRandomItems(array, 1).selected[0];
      }

      function transitionToNight() {
        setupCenterButton(null, null, false); // Hide the button during the night
        currentPhase = "night";
        canExecutePlayer = false; // No more executions
        phaseNumber++;
        updatePhaseDisplay();
        othernights();
        setTimeout(() => {
          currentPhase = "day";
          canExecutePlayer = true;
          updatePhaseDisplay();
          displayPlayerCircle(false);
          // When the day starts, show the button again if we are in kill mode
          if (isKillMode) {
            setupCenterButton("No Execution", transitionToNight);
          }
        }, nightPhaseMS);
      }

      function killPlayer(playerToken, id) {
        const player = gameStatePlayers[id];
        player.alive = false;
        playerToken.classList.add("dead");
      }

      function starpass() {
        // TODO: this
        // if a scarlet woman is alive + 5+ alive you pass to the scarlet woman
        // otherwise you pass to a random minion
      }

      // TODO: TPK evil wincon, do this after nightkills

      function executePlayer(playerToken, id) {
        // execution is not allowed during night phase
        if (!canExecutePlayer) {
          return;
        }

        const aliveCount = gameStatePlayers.filter((p) => p.alive).length;
        // no execution
        if (playerToken === null) {
          // check for mayor win
          const mayor = getRoleIfInPlay("Mayor");
          previousExecution = null;
          if (
            aliveCount === 3 &&
            mayor &&
            mayor.alive &&
            mayor.droisoned === false
          ) {
            // if mayor is alive in F3 and NOT droisoned, good wins
            endGame(true);
            return;
          }
        } else {
          // yes execution
          const player = gameStatePlayers[id];
          previousExecution = player;
          killPlayer(playerToken, id);
          const scarletWoman = getRoleIfInPlay("Scarlet Woman");
          if (player.role === "Imp") {
            // if the imp is executed, and the scarlet woman either does not exist, is dead, or is poisoned (lol)
            // or there is less than 5 players alive
            // then the evil team loses.

            const evilLoses =
              !scarletWoman ||
              !scarletWoman.alive ||
              scarletWoman.droisoned ||
              aliveCount < 5;
            if (evilLoses) {
              endGame(true);
              return;
            }
            // otherwise the scarlet woman becomes the imp
            scarletWoman.role = "Imp";
            scarletWoman.type = "demon";
          }

          // if a healthy saint is executed, their team loses.
          if (player.role === "Saint" && player.droisoned === false) {
            endGame(player.evil);
            return;
          }

          // if 2 or less players are alive, and a demon is alive, evil wins.
          const alivePlayers = gameStatePlayers.filter((p) => p.alive);
          if (alivePlayers.length <= 2) {
            const demon = alivePlayers.find((p) => p.type === "demon");
            if (demon) {
              endGame(false);
              return;
            }
          }
        }
        toggleKillModeBtn(); // TODO: this will break when we implement virgin
        transitionToNight();
      }

      function getRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.role === role) {
            return player;
          }
        }
        return null;
      }

      function getRoleIfHealthy(role) {
        const result = getRoleIfInPlay(role);
        return result && !result.droisoned;
      }

      // TODO: this also bricks for doubleclaims. only the first guy gets info on n1
      function getAppearsAsIfAlive(role) {
        for (player of gameStatePlayers) {
          if (player.appears_as.role === role && player.alive) {
            return player;
          }
        }
        return null;
      }

      // TODO: this bricks for doubleclaims. only the first guy gets info on n1
      function getAppearAsRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.appears_as.role === role) {
            return player;
          }
        }
        return null;
      }

      function flipCoin() {
        return percentTrue(50);
      }

      function percentTrue(percent) {
        return Math.random() < percent / 100;
      }

      function weightedRandom(distribution, exclude = []) {
        const filtered = distribution.map((w, i) =>
          exclude.includes(i) ? 0 : w
        );
        const total = filtered.reduce((a, b) => a + b, 0);
        if (total === 0)
          throw new Error("No valid options left after exclusions.");
        let r = Math.random() * total;
        for (let i = 0; i < filtered.length; i++) {
          r -= filtered[i];
          if (r < 0) return i;
        }
      }

      function countEvilPairs(players, recluseEvil, spyEvil) {
        let evilPairs = 0;
        const n = players.length;

        for (let i = 0; i < n; i++) {
          const current = players[i];
          const next = players[(i + 1) % n]; // wraps around to 0 at the end
          const currentEvil =
            current.role === "Recluse"
              ? recluseEvil
              : current.role === "Spy"
              ? spyEvil
              : current.evil;
          const nextEvil =
            next.role === "Recluse"
              ? recluseEvil
              : next.role === "Spy"
              ? spyEvil
              : next.evil;

          if (currentEvil && nextEvil) evilPairs++;
        }
        return evilPairs;
      }

      function getAllOutsiders() {
        return gameStatePlayers.filter((p) => p.type === "outsider");
      }

      function appendInfoText(player, text) {
        if (!player.info_text) {
          player.info_text = text;
        } else {
          player.info_text += `, ${text}`;
        }
      }

      function checkIsBaronPossible() {
        const outsiderClaims = gameStatePlayers.filter(
          (p) => p.appears_as.type === "outsider"
        );
        const outsiderCount = playerCounts[gameStatePlayers.length].outsiders;
        return outsiderClaims > outsiderCount;
      }

      function appendPreviousInfo(player, info) {
        if (!player.previous_info) {
          player.previous_info = [info];
        } else {
          player.previous_info.push(info);
        }
      }

      function night1() {
        // TODO: poisoner
        // TODO: if the poisoner ever dies or catches a starpass, their poisoning is removed.
        let poisoner = getRoleIfInPlay("Poisoner");
        if (poisoner) {
          // TODO: poison somebody good!
        }

        // picks a random good player and is more likely to pick someone neighboring the demon.
        let washerwoman = getAppearAsRoleIfInPlay("Washerwoman");
        if (washerwoman) {
          const spy = getRoleIfInPlay("Spy");
          let theDrunk = getRoleIfInPlay("Drunk");
          if (theDrunk && theDrunk.seat === washerwoman.seat) theDrunk = null;
          const evilWasherwoman = washerwoman.evil;
          const droisoned = washerwoman.droisoned;

          // pre-select an evil bluffing a townsfolk to confirm,
          // but not an evil washerwoman.
          // the drunk counts as an "evil player" for these purposes
          // there may be no one that meets this criteria.
          const evilsBluffingTownsfolk = gameStatePlayers.filter(
            (player) =>
              player.evil &&
              player.appears_as.type === "townsfolk" &&
              player.appears_as.role !== "Washerwoman"
          );
          const evilsAndDrunkBluffingTownsfolk = theDrunk
            ? [...evilsBluffingTownsfolk, theDrunk]
            : evilsBluffingTownsfolk;

          let evilToConfirm =
            evilsBluffingTownsfolk.length > 0
              ? getRandomItem(evilsBluffingTownsfolk)
              : null;
          let evilOrDrunkToConfirm =
            evilsAndDrunkBluffingTownsfolk.length > 0
              ? getRandomItem(evilsAndDrunkBluffingTownsfolk)
              : null;

          let correct;
          let wrong;
          let text;
          let seenRole;

          let confirmEvil = false;
          let confirmEvilOrDrunk = false;
          let learnRealInfo = false;
          let learnGarbage = false;

          if (evilWasherwoman) {
            // if no evil to confirm and no spy do random stuff
            if (!evilToConfirm && !spy) learnGarbage = true;
            // evil washerwoman confirms an allied evil player
            if (evilToConfirm && !spy) confirmEvil = true;
            // if spy in play but no evil to confirm, confirm a good player even tho ur evil lol ;)
            if (!evilToConfirm && spy) learnRealInfo = true;
            // if spy in play and evil to confirm u can confirm anyone good or evil
            if (evilToConfirm && spy) {
              if (percentTrue(33)) learnRealInfo = true;
              else confirmEvilOrDrunk = true;
            }
          } else if (droisoned) {
            // if no one is available to falsely confirm learn garbage
            if (!evilToConfirm) learnGarbage = true;
            // droisoned washerwoman falsely confirms sonmeone, or does random stuff (small chance)
            else if (percentTrue(10)) learnGarbage = true;
            else confirmEvilOrDrunk = true;
          } else if (spy) {
            // if spy in play, washerwoman picks a random townsfolk claim (even the drunk!) and confirms them
            const townsfolkClaims = gameStatePlayers.filter(
              (player) =>
                player.appears_as.type === "townsfolk" &&
                player.seat !== washerwoman.seat
            );
            const townsfolkToConfirm = getRandomItem(townsfolkClaims);
            seenRole = townsfolkToConfirm.appears_as.role;
            correct = townsfolkToConfirm;
            // if washerwoman would learn false info, the spy is the wrong side of the ping
            // unless they are confirming the spy's bluff in which case someone random is the wrong side
            const needsSpyWrong =
              townsfolkToConfirm.role.type !== "townsfolk" &&
              townsfolkToConfirm.role !== "Spy";
            if (needsSpyWrong) wrong = spy;
          } else {
            // if no spy in play, healthy washerwoman confirms a random good townsfolk
            learnRealInfo = true;
          }
          if (learnRealInfo) {
            const realTownsfolk = gameStatePlayers.filter(
              (player) =>
                player.type === "townsfolk" && player.seat !== washerwoman.seat
            );
            const townsfolkToConfirm = getRandomItem(realTownsfolk);
            correct = townsfolkToConfirm;
            seenRole = townsfolkToConfirm.role;
          } else if (confirmEvil) {
            correct = evilToConfirm;
            seenRole = evilToConfirm.appears_as.role;
          } else if (confirmEvilOrDrunk) {
            correct = evilOrDrunkToConfirm;
            seenRole = evilOrDrunkToConfirm.appears_as.role;
          } else if (learnGarbage) {
            // pick a random player (not yourself) and see a random townsfolk (not washerwoman).
            correct = getRandomItem(
              gameStatePlayers.filter(
                (player) => player.seat !== washerwoman.seat
              )
            );
            seenRole = getRandomItem(characters.townsfolk.slice(1)).name;
          }

          if (!wrong) {
            wrong = getRandomItem(
              gameStatePlayers.filter(
                (player) =>
                  player.seat !== correct.seat &&
                  player.seat !== washerwoman.seat
              )
            );
          }

          const order = flipCoin();
          text = `${order ? correct.name : wrong.name}/${
            order ? wrong.name : correct.name
          } ${seenRole}`;
          washerwoman.info_text = text;
          if (!washerwoman.evil) washerwoman.gameover_text = text;
        }
        // librarian
        let librarian = getAppearAsRoleIfInPlay("Librarian");
        if (librarian) {
          const spy = getRoleIfInPlay("Spy");
          const outsiders = getAllOutsiders();
          const zeroOutsidersPossible =
            gameStatePlayers.length === 7 ||
            gameStatePlayers.length === 10 ||
            gameStatePlayers.length === 13;
          const healthyLibrarian = !librarian.droisoned && !librarian.evil;
          const evilLibrarian = librarian.evil;
          // magic 1/5 chance for a healthy to ping off the spy
          // evil/drunk librarian has no need for a spy to misregister.
          const pingsOffSpy = healthyLibrarian && spy ? percentTrue(20) : false;
          // find all evil ppl bluffing outsider
          const evilOutsiders = gameStatePlayers.filter(
            (player) => player.evil && player.appears_as.type === "outsider"
          );
          let correct;
          let wrong;
          let text;
          let seenRole;

          let learnZero = false;
          let confirmEvil = false;
          let learnRealInfo = false;
          let learnRandomDrunk = false;
          let learnGarbage = false;

          if (pingsOffSpy) {
            // spy misinfo
            const mustConfirmSpy = spy.appears_as.type === "outsider";
            if (evilOutsiders.length === 0) {
              // random drunk ping
              correct = spy;
              seenRole = "Drunk";
            } else {
              // if spy is bluffing outsider confirm the spy
              if (mustConfirmSpy) {
                // confirm the spy
                correct = spy;
                seenRole = spy.appears_as.role;
              } else {
                // 3/4 confirm evil player. 1/4 drunk ping
                const confirmEvil = percentTrue(75);
                if (confirmEvil) {
                  // confirm an evil player
                  correct = getRandomItems(evilOutsiders, 1).selected[0];
                  wrong = spy;
                  seenRole = correct.appears_as.role;
                } else {
                  // spy influenced drunk ping
                  correct = spy;
                  seenRole = "Drunk";
                }
              }
            }
          } else if (healthyLibrarian) {
            if (outsiders.length === 0) {
              // if there's no outsiders you cannot learn any
              learnZero = true;
            } else {
              // learn a real outsider
              learnRealInfo = true;
            }
          } else {
            // librarian is droisoned/evil and will give harmful info
            const isBaronInPlay = !!getRoleIfInPlay("Baron");
            // the priority is to confirm your evil ally
            if (evilOutsiders.length > 0) {
              confirmEvil = true;
            } else if (evilHasGrim) {
              const confirmGoodPlayer = percentTrue(75);
              // confirm a good player for the cred
              if (confirmGoodPlayer) {
                if (outsiders.length === 0) {
                  // if there's no outsiders you cannot learn any
                  learnZero = true;
                } else {
                  // learn a real outsider
                  learnRealInfo = true;
                }
              } else {
                if (zeroOutsidersPossible && !isBaronInPlay) {
                  // claim 0 outsiders
                  learnZero = true;
                } else {
                  // make up a drunk ping
                  learnRandomDrunk = true;
                }
              }
            } else {
              if (zeroOutsidersPossible && !isBaronInPlay) {
                // claim 0 outsiders
                learnZero = true;
              } else {
                // make up a drunk ping
                learnRandomDrunk = true;
              }
            }
          }

          //  now that the action is decided execute the action
          if (learnZero) {
            text = "0";
          } else if (confirmEvil) {
            const evilAlly = getRandomItems(evilOutsiders, 1).selected[0];
            correct = evilAlly;
            seenRole = evilAlly.appears_as.role;
          } else if (learnRealInfo) {
            correct = getRandomItems(outsiders, 1).selected[0];
            seenRole = correct.role;
          } else if (learnRandomDrunk) {
            const anyoneButMe = getRandomItems(
              gameStatePlayers.filter((x) => x.seat !== librarian.seat),
              1
            ).selected[0];
            correct = anyoneButMe;
            seenRole = "Drunk";
          }

          if (correct) {
            if (!wrong) {
              wrong = getRandomItems(
                gameStatePlayers.filter(
                  (player) =>
                    player.seat !== correct.seat &&
                    player.seat !== librarian.seat
                ),
                1
              ).selected[0];
            }
            const order = flipCoin();
            text = `${order ? correct.name : wrong.name}/${
              order ? wrong.name : correct.name
            } ${seenRole}`;
          }
          if (!librarian.evil) librarian.gameover_text = text;
          librarian.info_text = text;
        }

        // investigator
        let invest = getAppearAsRoleIfInPlay("Investigator");
        if (invest) {
          const healthyInvest = !invest.droisoned && !invest.evil;
          const evilInvest = invest.evil;
          const isBaronPossible = checkIsBaronPossible();

          // outcomes
          let learnRealInfo = false;
          let learnRecluse = false;
          let learnGoodPlayers = false;
          let correct;
          let wrong;
          let seenRole;
          let text;

          // sober investigators have 20% to get trolled by a recluse
          if (healthyInvest && getRoleIfHealthy("Recluse") && percentTrue(20))
            learnRecluse = true;

          // sober investigator learns a minion. priority is on non-scarlet woman
          // might get trolled by a recluse.
          if (healthyInvest && !learnRecluse) learnRealInfo = true;
          // drunk investigator sees a random minion (again probably not SW) between 2 good ppl.
          if (!healthyInvest && !evilInvest) learnGoodPlayers = true;

          // evil investigator
          if (evilInvest) {
            const minionsToBus = gameStatePlayers.filter(
              (p) =>
                p.type === "minion" &&
                p.role !== "Scarlet Woman" &&
                p.seat !== invest.seat
            );
            const existsMinionToBus =
              invest.type === "demon" || minionsToBus.length > 0;
            if (percentTrue(15) && existsMinionToBus) learnRealInfo = true;
            else learnGoodPlayers = true;
          }
          const randomMinionArray = ["Poisoner", "Spy"];
          const minionCount = playerCounts[gameStatePlayers.length].minions;
          // if 1 minion in play: learn a random minion
          if (minionCount === 1) randomMinionArray.push("Scarlet Woman");
          isBaronPossible && randomMinionArray.push("Baron");
          const goodPpl = gameStatePlayers.filter(
            (p) => !p.evil && p.seat !== invest.seat
          );
          if (learnRealInfo) {
            // if 1 minion in play: learn that minion
            if (minionCount === 1) {
              const minion = gameStatePlayers.filter(
                (p) => p.type === "minion"
              )[0];
              correct = minion;
              seenRole = minion.role;
            } else {
              // if 2+ minions in play: learn one that isnt the scarlet woman (and not yourself lol)
              const minions = gameStatePlayers.filter(
                (p) =>
                  p.type === "minion" &&
                  p.role !== "Scarlet Woman" &&
                  p.seat !== invest.seat
              );
              if (minions.length === 0) throw "NO MINION ERROR";
              correct = getRandomItem(minions);
              seenRole = correct.role;
            }
          } else if (learnRecluse) {
            const recluse = getRoleIfInPlay("Recluse");
            correct = recluse;
            seenRole = getRandomItem(randomMinionArray);
          } else if (learnGoodPlayers) {
            const picks = getRandomItems(goodPpl, 2).selected;
            correct = picks[0];
            wrong = picks[1];
            seenRole = getRandomItem(randomMinionArray);
          }

          // wrong is always a good player.
          if (!wrong) {
            const validWrongChoices = goodPpl.filter(
              (p) => p.seat !== correct.seat
            );
            const finalWrongChoices =
              seenRole === "Baron"
                ? validWrongChoices.filter(
                    (p) => p.role !== "Saint" && p.role !== "Butler"
                  )
                : validWrongChoices;
            wrong = getRandomItem(finalWrongChoices);
          }
          const order = flipCoin();
          text = `${order ? correct.name : wrong.name}/${
            order ? wrong.name : correct.name
          } ${seenRole}`;
          if (!invest.evil) invest.gameover_text = text;
          invest.info_text = text;
        }
        // chef
        let chef = getAppearAsRoleIfInPlay("Chef");
        if (chef) {
          // check how many evil players are sitting next to each other in the circle
          const recluseEvil = getRoleIfHealthy("Recluse") && flipCoin(); // the recluse is evil for chef # if he is in the game, sober, and 50% chance
          const spyEvil = flipCoin();
          let correctEvilPairs = countEvilPairs(
            gameStatePlayers,
            recluseEvil,
            spyEvil
          );
          // although it is technically possible, i will never give a chef 5.
          if (correctEvilPairs === 5) correctEvilPairs = 4;
          let returnedEvilPairs = correctEvilPairs;

          // a droisoned chef gets false info
          if (chef.droisoned) {
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length],
              [correctEvilPairs]
            );
          } else if (chef.evil) {
            // an evil chef just says something random
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length]
            );
          } else {
            // a good chef learns the truth
            chef.gameover_text = `${returnedEvilPairs}`;
          }
          chef.info_text = `${returnedEvilPairs}`;
        }
        // TODO: empath
        let empath = getAppearAsRoleIfInPlay("Empath");
        if (empath) {
          // TODO: night 1 empath.
          // sober+good empath gets true info, might misregister on recluse/spy
          // drunk empath gets false info
          // evil empath frames their allies as good and may or may not claim a 1 or 2 on good ppl
        }
        // TODO: fortune teller
        let ft = getAppearAsRoleIfInPlay("Fortune Teller");
        if (ft) {
          // TODO: night 1 fortune teller
          // if the FT is real, set up a red herring
          // if the FT is drunk/evil, set up a frame map, but always give a no on the demon
          // unless its late in the game or something then you might give a yes idk
          // recluses usually give a yes
        }
      }

      function othernights() {
        // TODO: unpoison whoever was poisoned last night, but not The Drunk
        // TODO: poisoner
        // TODO: monk
        // TODO: imp
        // TODO: ravenkeeper
        // TODO: undertaker
        const undertaker = getAppearsAsIfAlive("Undertaker");
        if (undertaker && previousExecution) {
          // sober undertaker: see the role of the preivous executee
          const soberUndertaker = !undertaker.droisoned && !undertaker.evil;
          const droisonedUndertaker = undertaker.droisoned && !undertaker.evil;
          const evilUndertaker = undertaker.evil;

          let infotext = "Unimplemented";

          let learnRealInfo = false;
          let confirmEvilPlayer = false;
          let frameGoodPlayer = false;
          let learnRandomGarbage = false;

          if (soberUndertaker) {
            // sober undertaker can get trolled by recluse and spy, otherwise learn good info
            if (previousExecution.role === "Spy" && percentTrue(60)) {
              confirmEvilPlayer = true;
            } else if (
              previousExecution.role === "Recluse" &&
              percentTrue(60) &&
              !previousExecution.droisoned
            ) {
              frameGoodPlayer = true;
            } else {
              learnRealInfo = true;
            }
          } else if (droisonedUndertaker || (evilUndertaker && !evilHasGrim)) {
            // droisoned and evil spyless undertaker are the same thing
            // that way it gives more credibility to evil players who don't have a spy
            // TODO: random stuff here. confirm evil players, frame good players, or make random guesses on any player.
            //
            // however they might want to frame a fake invest ping as real.
            // they might want to frame a fake fortune teller yes as an imp.
            // they might want to support a fake empath's story.
            // complicated business around here for real.
            //
          } else if (evilUndertaker) {
            // if evil has a spy they can be a "real" undertaker except they can frame a few good players here and there
            // TODO: this
            // an undertaker with a spy sees info and can corraborate stories, real or fake
          }

          if (learnRealInfo) {
            infotext = `${previousExecution.name} ${previousExecution.role}`;
            appendPreviousInfo(undertaker, previousExecution.role);
          } else if (confirmEvilPlayer) {
            infotext = `${previousExecution.name} ${previousExecution.appears_as.role}`;
            appendPreviousInfo(undertaker, previousExecution.appears_as.role);
          } else if (frameGoodPlayer) {
            // TODO: draw from a pool of evil roles, you could repeat something you saw. but make it less likely? idk.
            // you can learn imp only one time,,, hmm
            // TODO: the bluffs here are complicated and contextual lets do other stuff first...??????
            //
            // "evil pool" contains Drunk if they are a townsfolk,
            // it includes Baron if baron is possible.
          } else if (learnRandomGarbage) {
            // learn a random role you haven't learned yet! but not undertaker.
            // TODO: this as well
          }

          // recluse could be evil; spy could be good
          // if no execution, always empty string
          // poisoned: see Drunk, garbage, evil role... maybe true info on a good player but not an evil one for sure.
          // evil: see allies as good.
          // if spy in play, can confirm good ppl. can also frame people as evil.
          appendInfoText(undertaker, infotext);
          if (!evilUndertaker) {
            undertaker.gameover_text = undertaker.info_text;
          }
        }
        // TODO: empath
        const empath = getAppearsAsIfAlive("Empath");
        if (empath) {
          // sober empath needs to keep track of who is being framed as evil/good for spy/recluse
        }
        // TODO: ft

        // if 2 or less players are alive, and a demon is alive, evil wins.
        const alivePlayers = gameStatePlayers.filter((p) => p.alive);
        if (alivePlayers.length <= 2) {
          const demon = alivePlayers.find((p) => p.type === "demon");
          if (demon) {
            endGame(false);
            return;
          }
        }
      }

      function generateAndDisplayScript() {
        evilHasGrim = false;
        previousExecution = null;
        killModeToggleBtn.disabled = false;
        canExecutePlayer = true;
        phaseDisplay.classList.remove("good-wins", "evil-wins");

        setupCenterButton(null, null, false);
        const playerCount = parseInt(playerCountSelect.value, 10);
        let counts = { ...playerCounts[playerCount] };
        const baseOutsiderCount = counts.outsiders;

        // --- SCRIPT GENERATION ---
        // generate demon (its imp!)
        const selectedDemons = getRandomItems(
          characters.demons,
          counts.demons
        ).selected;
        // generate minions
        const selectedMinions = getRandomItems(
          characters.minions,
          counts.minions
        ).selected;
        const isBaronInPlay = selectedMinions.some(
          (minion) => minion.name === "Baron"
        );

        if (isBaronInPlay) {
          counts.townsfolk -= 2;
          counts.outsiders += 2;
        }
        const spyInPlay = selectedMinions.some(
          (minion) => minion.name === "Spy"
        );
        evilHasGrim = spyInPlay;
        // generate outsiders
        const outsiderRNG = getRandomItems(
          characters.outsiders,
          counts.outsiders
        );
        const selectedOutsiders = outsiderRNG.selected;
        const notInPlayOutsiders = outsiderRNG.notSelected;

        const townsfolkRNG = getRandomItems(
          characters.townsfolk,
          counts.townsfolk
        );
        const selectedTownsfolk = townsfolkRNG.selected;
        const notInPlayTownsfolk = townsfolkRNG.notSelected;

        const faceUpOutsiders = selectedOutsiders.filter(
          (item) => item.name !== "Drunk"
        ).length;

        // calculate correct number of outsider bluffs that can be given
        let maxOutsiderBluffs = baseOutsiderCount + 2 - faceUpOutsiders;

        const bluffableOutsiders = notInPlayOutsiders
          .filter((item) => item.name !== "Drunk")
          .slice(0, maxOutsiderBluffs);

        // if there is a drunk, pop one item from notinplaytownsfolk
        const isDrunkInPlay =
          selectedOutsiders.findIndex((o) => o.name === "Drunk") > -1;
        const designatedDrunkBluff = isDrunkInPlay
          ? notInPlayTownsfolk.pop()
          : null;

        const bluffRNG = getRandomItems(
          [...bluffableOutsiders, ...notInPlayTownsfolk],
          3
        );
        const demonBluffs = bluffRNG.selected;
        const unusedBluffs = bluffRNG.notSelected;

        if (selectedMinions.length === 3) {
          // if there is spy, you get another free bluff! yay
          if (spyInPlay) {
            demonBluffs.push(unusedBluffs[0]);
          } else {
            // otherwise you just have to randomly claim something.
            const roleToClaim = getRandomItems(
              [...characters.townsfolk, ...characters.outsiders].filter(
                (role) => role.name !== "Drunk"
              ),
              1
            ).selected[0];
            demonBluffs.push(roleToClaim);
          }
        }
        const ingamePlayers = shuffleArray(playerNames.slice(0, playerCount));

        const shuffledTokens = shuffleArray([
          ...selectedDemons,
          ...selectedMinions,
          ...selectedOutsiders,
          ...selectedTownsfolk,
        ]);

        // collect all the tokens and then turn them into players
        let demonBluffIndex = 0;
        gameStatePlayers = [];
        for (let i = 0; i < shuffledTokens.length; i++) {
          // minions/demons each get a bluff
          const token = shuffledTokens[i];
          let appears_as = { role: token.name, type: token.type };
          let gameover_text = "";
          if (token.type === "minion" || token.type === "demon") {
            appears_as = {
              role: demonBluffs[demonBluffIndex].name,
              type: demonBluffs[demonBluffIndex].type,
            };
            gameover_text = `I was the ${token.name} bluffing ${appears_as.role}`;
            demonBluffIndex++;
          }
          if (token.name === "Drunk") {
            appears_as = {
              role: designatedDrunkBluff.name,
              type: designatedDrunkBluff.type,
            };
            gameover_text = `I saw myself as ${designatedDrunkBluff.name}`;
          }
          const player = {
            seat: i,
            name: ingamePlayers[i],
            role: token.name,
            type: token.type,
            evil: token.evil,
            alive: true,
            appears_as,
            info_text: "",
            droisoned: token.name === "Drunk",
            gameover_text,
          };
          gameStatePlayers.push(player);
        }

        night1();
        phaseNumber = 1;
        updatePhaseDisplay();
        displayPlayerCircle(false);
      }

      function displayPlayerCircle(grim_reveal = false) {
        circleContainer.innerHTML = "";
        const playerCount = gameStatePlayers.length;
        console.log(gameStatePlayers); // TODO: debug mode
        const radius = circleContainer.offsetWidth / 2 - 70; // 70 is a magic number for spacing

        for (let i = 0; i < playerCount; i++) {
          const player = gameStatePlayers[i];
          const angle = (i / playerCount) * 360;
          const angleRad = angle * (Math.PI / 180);

          const x = radius * Math.cos(angleRad);
          const y = radius * Math.sin(angleRad);

          const role = grim_reveal ? player : player.appears_as;
          const playerName = player.name;

          const tokenEl = document.createElement("div");
          tokenEl.className = `player-token ${role.type} ${
            player.alive ? "" : "dead"
          }`;

          // The transform places the element around the circle. The final rotate(-angle) keeps the text upright.
          tokenEl.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg) translate(60px) rotate(-${angle}deg)`;

          let speech = "";

          if (grim_reveal) {
            speech = player.gameover_text || "";
          } else {
            speech = player.info_text || "";
          }

          tokenEl.innerHTML = `
                    <div class="speech-bubble${
                      speech ? " visible" : ""
                    }">${speech}</div>
                    <strong>${playerName}</strong>
                    <span>${role.role}</span>
                  `;
          // Add a click listener to toggle the 'dead' class on the token.
          // This allows you to mark players as executed.
          tokenEl.addEventListener("click", () => {
            if (isKillMode) {
              executePlayer(tokenEl, i);
            }
            // TODO: If kill mode is off, clicking does nothing. (for now)
          });

          circleContainer.appendChild(tokenEl);
        }
      }

      function endGame(goodWon) {
        isKillMode = false;
        document.body.classList.remove("kill-mode-active");
        container.classList.remove("kill-mode-active");
        killModeToggleBtn.textContent = "Execute Mode: OFF";

        killModeToggleBtn.disabled = true;

        phaseDisplay.classList.remove("good-wins", "evil-wins");
        phaseDisplay.textContent = goodWon ? "GOOD WIN" : "EVIL WIN";
        phaseDisplay.classList.add(goodWon ? "good-wins" : "evil-wins");

        setupCenterButton(null, null, false);

        canExecutePlayer = false;

        displayPlayerCircle(true); // grim reveal
      }

      // ----- GOOD for some nice RNG  ----
      // function main() {
      //   for (let i = 0; i < 40000; i++) {
      //     generateAndDisplayScript();
      //     x[
      //       countEvilPairs(gameStatePlayers, flipCoin(), flipCoin())
      //     ]++;
      //   }
      //   console.log(x);
      // }

      document.addEventListener("DOMContentLoaded", generateAndDisplayScript);
      generateBtn.addEventListener("click", generateAndDisplayScript);
      centerActionButton.addEventListener("click", () => {
        if (typeof currentCenterAction === "function") {
          currentCenterAction(); // Execute the stored function
        }
      });
    </script>
  </body>
</html>
