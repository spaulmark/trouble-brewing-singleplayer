<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clocktower Simulator</title>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --text-color: #e0e0e0;
        --primary-color: #a02c2c;
        --card-bg: #2c2c2c;
        --border-color: #444;
        --townsfolk-color: #2e86c1;
        --outsider-color: #85c1e9;
        --minion-color: #e74c3c;
        --demon-color: #c0392b;
      }
      #center-action-btn {
        position: absolute;
        top: 65%; /* Position it below the DAY/NIGHT text */
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20; /* Make sure it's on top */

        padding: 10px 20px;
        font-size: 1.1em;
        font-weight: bold;
        background-color: #555;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;

        /* For the fade-in/out effect */
        visibility: hidden;
        opacity: 0;
      }

      #center-action-btn:hover {
        background-color: #666;
        border-color: #777;
      }

      /* A class to make the button visible */
      #center-action-btn.visible {
        visibility: visible;
        opacity: 1;
      }
      #kill-mode-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        font-size: 1em;
        font-weight: bold;
        background-color: #333;
        color: var(--text-color);
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        z-index: 1000;
        transition: background-color 0.3s, color 0.3s;
      }

      body.kill-mode-active #kill-mode-toggle {
        background-color: var(--primary-color);
        color: white;
        border-color: #c0392b;
      }

      body {
        transition: background-color 0.4s ease;
      }

      body.kill-mode-active {
        background-color: #2a1a1a;
      }

      .container.kill-mode-active {
        background-color: rgb(70, 40, 40);
        transition: background-color 0.3s, color 0.3s;
      }

      /* Change cursor to crosshair on tokens ONLY when in kill mode */
      body.kill-mode-active .player-token {
        cursor: crosshair;
      }

      .player-token {
        position: relative;
      }

      .speech-bubble {
        pointer-events: none;
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 10px;

        background-color: #e0e0e0;
        color: #1a1a1a;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 0.85em;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        width: 140px;

        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .speech-bubble::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 8px;
        border-style: solid;
        border-color: #e0e0e0 transparent transparent transparent;
      }

      .speech-bubble.visible {
        visibility: visible;
        opacity: 1;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: var(--card-bg);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: background-color 0.3s, color 0.3s;
      }

      h1,
      h2,
      h3 {
        text-align: center;
        color: var(--primary-color);
        text-transform: uppercase;
        letter-spacing: 2px;
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 10px;
        margin-bottom: 20px;
      }

      .controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 30px;
      }

      .controls label {
        font-size: 1.1em;
        font-weight: bold;
      }

      #player-count,
      #generate-btn {
        padding: 10px 15px;
        font-size: 1em;
        border-radius: 5px;
        border: 1px solid var(--border-color);
        background-color: #333;
        color: var(--text-color);
        cursor: pointer;
      }

      #generate-btn {
        background-color: var(--primary-color);
        color: white;
        font-weight: bold;
        transition: background-color 0.2s ease;
      }

      #generate-btn:hover {
        background-color: #c0392b;
      }

      .script-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
        visibility: hidden;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      li {
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
      }
      li strong {
        display: inline;
        font-size: 1.1em;
        color: #fff;
      }
      li .ability {
        display: block;
        margin-top: 5px;
      }
      .drunk-marker {
        font-weight: bold;
        font-style: italic;
        color: var(--outsider-color);
        margin-left: 8px;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      #phase-display {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        user-select: none;

        font-size: 7em;
        font-weight: bold;
        color: rgba(224, 224, 224, 0.1);
        text-transform: uppercase;
        letter-spacing: 5px;
        text-align: center;
        pointer-events: none;
        z-index: 10;
      }
      #phase-display.good-wins {
        color: var(--townsfolk-color);
        opacity: 1;
      }
      #phase-display.evil-wins {
        color: var(--demon-color);
        opacity: 1;
      }
      /* --- Player Circle Display --- */
      #player-assignments h2 {
        margin-top: 40px;
      }

      .circle-container {
        position: relative;
        width: 725px;
        height: 725px;
        margin: 100px auto 40px;
        border: 2px dashed var(--border-color);
        border-radius: 50%;
      }

      .player-token {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 120px;
        height: 60px;
        margin: -30px 0 0 -60px;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;

        border: 3px solid yellow;
        border-radius: 8px;
        background-color: var(--card-bg);
        font-size: 0.9em;

        transition: opacity 0.1s ease;
        user-select: none;

        transition: box-shadow 0.1s ease-out, transform 0.1s ease-out;
        will-change: transform, box-shadow;
      }

      .player-token.townsfolk:hover {
        box-shadow: 0 0 15px 3px var(--townsfolk-color);
      }
      .player-token.outsider:hover {
        box-shadow: 0 0 15px 3px var(--outsider-color);
      }
      .player-token.minion:hover {
        box-shadow: 0 0 15px 3px var(--minion-color);
      }
      .player-token.demon:hover {
        box-shadow: 0 0 15px 3px var(--demon-color);
      }

      /* dead ppl dont glow */
      .player-token.dead:hover {
        transform: none;
        box-shadow: none;
        cursor: not-allowed;
      }

      /* Style for dead players */
      .player-token.dead {
        opacity: 0.4;
      }
      .player-token.dead strong,
      .player-token.dead span {
        text-decoration: line-through;
      }

      .player-token strong {
        font-size: 1.1em;
        color: var(--text-color);
      }
      .player-token span {
        font-weight: bold;
      }

      /* Color coding the tokens by role type */
      .player-token.townsfolk {
        border-color: var(--townsfolk-color);
      }
      .player-token.townsfolk span {
        color: var(--townsfolk-color);
      }

      .player-token.outsider {
        border-color: var(--outsider-color);
      }
      .player-token.outsider span {
        color: var(--outsider-color);
      }

      .player-token.minion {
        border-color: var(--minion-color);
      }
      .player-token.minion span {
        color: var(--minion-color);
      }

      .player-token.demon {
        border-color: var(--demon-color);
      }
      .player-token.demon span {
        color: var(--demon-color);
      }
    </style>
  </head>
  <body>
    <div class="container" id="container">
      <div class="controls">
        <label for="player-count">Select Player Count:</label>
        <select id="player-count">
          <option value="7">7 Players</option>
          <option value="8">8 Players</option>
          <option value="9">9 Players</option>
          <option value="10">10 Players</option>
          <option value="11">11 Players</option>
          <option value="12" selected>12 Players</option>
          <option value="13">13 Players</option>
          <option value="14">14 Players</option>
          <option value="15">15 Players</option>
        </select>
        <button id="generate-btn">New Game</button>
      </div>
      <div id="player-assignments">
        <div id="phase-display"></div>
        <button id="center-action-btn"></button>
        <div class="circle-container" id="circle-container">
          <!-- players appear here -->
        </div>
        <button id="kill-mode-toggle">Execute Mode: OFF</button>
      </div>
    </div>

    <script>
      // --- DATA ---
      const characters = {
        townsfolk: [
          {
            name: "Washerwoman",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Librarian",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Investigator",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Chef",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Empath",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Fortune Teller",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Undertaker",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Monk",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Ravenkeeper",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Virgin",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Slayer",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Soldier",
            type: "townsfolk",
            evil: false,
          },
          {
            name: "Mayor",
            type: "townsfolk",
            evil: false,
          },
        ],
        outsiders: [
          {
            name: "Butler",
            type: "outsider",
            evil: false,
          },
          {
            name: "Drunk",
            type: "outsider",
            evil: false,
          },
          {
            name: "Recluse",
            type: "outsider",
            evil: false,
          },
          {
            name: "Saint",
            type: "outsider",
            evil: false,
          },
        ],
        minions: [
          {
            name: "Poisoner",
            type: "minion",
            evil: true,
          },
          {
            name: "Spy",
            type: "minion",
            evil: true,
          },
          {
            name: "Scarlet Woman",
            type: "minion",
            evil: true,
          },
          {
            name: "Baron",
            type: "minion",
            evil: true,
          },
        ],
        demons: [
          {
            name: "Imp",
            type: "demon",
            evil: true,
          },
        ],
      };

      const playerCounts = {
        7: { townsfolk: 5, outsiders: 0, minions: 1, demons: 1 },
        8: { townsfolk: 5, outsiders: 1, minions: 1, demons: 1 },
        9: { townsfolk: 5, outsiders: 2, minions: 1, demons: 1 },
        10: { townsfolk: 7, outsiders: 0, minions: 2, demons: 1 },
        11: { townsfolk: 7, outsiders: 1, minions: 2, demons: 1 },
        12: { townsfolk: 7, outsiders: 2, minions: 2, demons: 1 },
        13: { townsfolk: 9, outsiders: 0, minions: 3, demons: 1 },
        14: { townsfolk: 9, outsiders: 1, minions: 3, demons: 1 },
        15: { townsfolk: 9, outsiders: 2, minions: 3, demons: 1 },
      };

      const playerNames = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
      ];

      // --- Ugly Number Data ---

      const chefNumbers = {
        7: [27112, 12350, 538, 0, 0, 0],
        8: [26668, 12319, 1013, 0, 0, 0],
        9: [26484, 12371, 1145, 0, 0, 0],
        10: [18741, 17440, 3617, 202, 0, 0],
        11: [18805, 16849, 4081, 265, 0, 0],
        12: [18988, 16524, 4198, 290, 0, 0],
        13: [12975, 18240, 7589, 1154, 42, 0],
        14: [13158, 18012, 7590, 1185, 55, 0],
        15: [13333, 17744, 7654, 1216, 53, 0],
      };

      // --- Dom Elements ---
      const playerCountSelect = document.getElementById("player-count");
      const generateBtn = document.getElementById("generate-btn");
      const circleContainer = document.getElementById("circle-container");
      const container = document.getElementById("container");
      const phaseDisplay = document.getElementById("phase-display");
      const centerActionButton = document.getElementById("center-action-btn");
      const killModeToggleBtn = document.getElementById("kill-mode-toggle");

      // magic numbers
      let nightPhaseMS = 1500;

      // game state variables
      let evilHasGrim = false;
      let currentPhase = "day";
      let phaseNumber = 1;
      let gameStatePlayers = [
        /*{
                    seat: 0,
                    name: "ABCDEFG"
                    character:  "drunk",
                    type: "outsider"
                    evil: true/false     // only 2 alignments in botc
                    alive: true/false
                    appears_as: {role: "mayor", type: "townsfolk"}
                    my_info_text: "A/B yes, C/D no",
                    gameover_text: "i saw myself as mayor",
                    droisoned: true/false
                  }*/
      ];
      /*
                  role template:
                  fortune teller: {
                  default_choicebubble: "Who should I pick tonight?"
                  }
                  */

      // ui state variables
      let currentCenterAction = null;
      let canExecutePlayer = true;
      let isKillMode = false;

      // TODO: create a grim reveal button
      // it makes you lose and reveals the grim and enables the new game button

      function toggleKillModeBtn() {
        isKillMode = !isKillMode;
        document.body.classList.toggle("kill-mode-active", isKillMode);
        container.classList.toggle("kill-mode-active", isKillMode);

        if (isKillMode) {
          killModeToggleBtn.textContent = "Execute Mode: ON";
          // If it's daytime, show the "No Execution" button
          if (currentPhase === "day") {
            setupCenterButton("No Execution", () => executePlayer(null, -1));
          }
        } else {
          killModeToggleBtn.textContent = "Execute Mode: OFF";
          // Always hide the button when not in kill mode
          setupCenterButton(null, null, false);
        }
      }

      killModeToggleBtn.addEventListener("click", () => toggleKillModeBtn());

      function updatePhaseDisplay() {
        if (phaseDisplay) {
          // Check that the element exists
          phaseDisplay.textContent = `${currentPhase.toUpperCase()} ${phaseNumber}`;
        }
      }

      // --- UI Logic ---

      function setupCenterButton(text, action, isVisible = true) {
        if (isVisible) {
          centerActionButton.textContent = text;
          currentCenterAction = action; // Assign the function to our variable
          centerActionButton.classList.add("visible");
        } else {
          centerActionButton.classList.remove("visible");
          currentCenterAction = null; // Clear the action
        }
      }

      // --- GAME LOGIC ---
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function getRandomItems(array, numItems) {
        const shuffled = shuffleArray([...array]);
        const selected = shuffled.slice(0, numItems);
        const notSelected = shuffled.slice(numItems);
        return { selected, notSelected };
      }

      function transitionToNight() {
        setupCenterButton(null, null, false); // Hide the button during the night
        currentPhase = "night";
        canExecutePlayer = false; // No more executions
        phaseNumber++;
        updatePhaseDisplay();
        othernights();
        setTimeout(() => {
          currentPhase = "day";
          canExecutePlayer = true;
          updatePhaseDisplay();
          // When the day starts, show the button again if we are in kill mode
          if (isKillMode) {
            setupCenterButton("No Execution", transitionToNight);
          }
        }, nightPhaseMS);
      }

      function killPlayer(playerToken, id) {
        const player = gameStatePlayers[id];
        player.alive = false;
        playerToken.classList.add("dead");
      }

      function starpass() {
        // TODO: this
        // if a scarlet woman is alive you pass to the scarlet woman
        // otherwise you pass to a random minion
      }

      // TODO: TPK evil wincon, do this after nightkills

      function executePlayer(playerToken, id) {
        // execution is not allowed during night phase
        if (!canExecutePlayer) {
          return;
        }

        // no execution
        if (playerToken === null) {
          // check for mayor win
          const aliveCount = gameStatePlayers.filter((p) => p.alive).length;
          const mayor = getRoleIfInPlay("Mayor");
          if (
            aliveCount === 3 &&
            mayor &&
            mayor.alive &&
            mayor.droisoned === false
          ) {
            // if mayor is alive in F3 and NOT droisoned, good wins
            endGame(true);
            return;
          }
        } else {
          // yes execution
          const player = gameStatePlayers[id];
          killPlayer(playerToken, id);
          const scarletWoman = getRoleIfInPlay("Scarlet Woman");
          if (player.role === "Imp") {
            // if the imp is executed, and the scarlet woman either does not exist, is dead, or is poisoned (lol)
            // then the evil team loses.
            const evilLoses =
              !scarletWoman || !scarletWoman.alive || scarletWoman.droisoned;
            if (evilLoses) {
              endGame(true);
              return;
            }
            // otherwise the scarlet woman becomes the imp
            scarletWoman.role = "Imp";
            scarletWoman.type = "demon";
          }

          // if a healthy saint is executed, their team loses.
          if (player.role === "Saint" && player.droisoned === false) {
            endGame(player.evil);
            return;
          }

          // if 2 or less players are alive, and a demon is alive, evil wins.
          const alivePlayers = gameStatePlayers.filter((p) => p.alive);
          if (alivePlayers.length <= 2) {
            const demon = alivePlayers.find((p) => p.type === "demon");
            if (demon) {
              endGame(false);
              return;
            }
          }
        }
        toggleKillModeBtn(); // TODO: this will break when we implement virgin
        transitionToNight();
      }

      function getRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.role === role) {
            return player;
          }
        }
        return null;
      }

      function getAppearAsRoleIfInPlay(role) {
        for (player of gameStatePlayers) {
          if (player.appears_as.role === role) {
            return player;
          }
        }
        return null;
      }

      function flipCoin() {
        return percentTrue(50);
      }

      function percentTrue(percent) {
        return Math.random() < percent / 100;
      }

      function weightedRandom(distribution, exclude = []) {
        const filtered = distribution.map((w, i) =>
          exclude.includes(i) ? 0 : w
        );
        const total = filtered.reduce((a, b) => a + b, 0);
        if (total === 0)
          throw new Error("No valid options left after exclusions.");
        let r = Math.random() * total;
        for (let i = 0; i < filtered.length; i++) {
          r -= filtered[i];
          if (r < 0) return i;
        }
      }

      function countEvilPairs(players, recluseEvil, spyEvil) {
        let evilPairs = 0;
        const n = players.length;

        for (let i = 0; i < n; i++) {
          const current = players[i];
          const next = players[(i + 1) % n]; // wraps around to 0 at the end
          const currentEvil =
            current.role === "Recluse"
              ? recluseEvil
              : current.role === "Spy"
              ? spyEvil
              : current.evil;
          const nextEvil =
            next.role === "Recluse"
              ? recluseEvil
              : next.role === "Spy"
              ? spyEvil
              : next.evil;

          if (currentEvil && nextEvil) evilPairs++;
        }
        return evilPairs;
      }

      function getAllOutsiders() {
        return gameStatePlayers.filter((p) => p.type === "outsider");
      }

      function night1() {
        // TODO: poisoner
        // TODO: washerwoman
        // librarian

        // TODO: it's librarian time
        let librarian = getAppearAsRoleIfInPlay("Librarian");
        if (librarian) {
          const spy = getRoleIfInPlay("Spy");
          const outsiders = getAllOutsiders();
          const zeroOutsidersPossible =
            gameStatePlayers.length === 7 ||
            gameStatePlayers.length === 10 ||
            gameStatePlayers.length === 13;
          const healthyLibrarian = !librarian.droisoned && !librarian.evil;
          const evilLibrarian = librarian.evil;
          // pick a a random outsider, or the spy. or if there are no outsiders say there are none
          // if you pick the spy, the priority is to confirm an evil outsider bluff
          // otherwise it's "you saw a drunk" between the spy and a random person (not yourself)
          // if there is only a spy in play you could still learn no outsiders

          // 1/5 chance for a healthy to ping off the spy
          // evil/drunk librarian has no need for a spy to misregister.
          const pingsOffSpy = healthyLibrarian && spy ? percentTrue(20) : false;

          // or they will ping off of the spy and confirm an evil player bluffing outsider
          // or they will ping off the spy and see random drunk pings
          if (pingsOffSpy) {
            // TODO: spy misinfo
            // either confirm an evil player,
            // see random drunk pings
            // see garbage info
          } else if (healthyLibrarian) {
            let text;
            if (outsiders.length === 0) {
              // if there's no outsiders you cannot learn any
              text = "0";
            } else {
              // learn a real outsider
              const correct = getRandomItems(outsiders, 1).selected[0];
              const wrong = getRandomItems(
                gameStatePlayers.filter(
                  (player) =>
                    player.seat !== correct.seat &&
                    player.seat !== librarian.seat
                ),
                1
              ).selected[0];
              const order = flipCoin();
              text = `${order ? correct.name : wrong.name}/${
                order ? wrong.name : correct.name
              } ${correct.role}`;
            }
            librarian.gameover_text = text;
            librarian.info_text = text;
          } else if (evilLibrarian) {
            // TODO: be evil
            // confirm your evil ally
            // confirm a good player (if spy in play)
            // maybe claim 0 outsiders (if 7/10/13 game)
            // claim 2 random pings
          } else {
            // TODO: droisoned librarian
            // confirm an evil player
            // see 2 random drunk pings
            // see 2 random ppl
            // incorrectly learn 0 outsiders  (if 7/10/13 game)
          }
        }

        // TODO: investigator
        // chef
        let chef = getAppearAsRoleIfInPlay("Chef");
        if (chef) {
          // check how many evil players are sitting next to each other in the circle
          const recluseEvil = flipCoin();
          const spyEvil = flipCoin();
          let correctEvilPairs = countEvilPairs(
            gameStatePlayers,
            recluseEvil,
            spyEvil
          );
          // although it is technically possible, i will never give a chef 5.
          if (correctEvilPairs === 5) correctEvilPairs = 4;
          let returnedEvilPairs = correctEvilPairs;

          // a droisoned chef gets false info
          if (chef.droisoned) {
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length],
              [correctEvilPairs]
            );
          } else if (chef.evil) {
            // an evil chef just says something random
            returnedEvilPairs = weightedRandom(
              chefNumbers[gameStatePlayers.length]
            );
          } else {
            // a good chef learns the truth
            chef.gameover_text = `${returnedEvilPairs}`;
          }
          chef.info_text = `${returnedEvilPairs}`;
        }
        // TODO: empath
        // TODO: fortune teller
      }

      function othernights() {
        // TODO: poisoner
        // TODO: monk
        // TODO: imp
        // TODO: ravenkeeper
        // TODO: undertaker
        // TODO: empath
        // TODO: ft

        // if 2 or less players are alive, and a demon is alive, evil wins.
        const alivePlayers = gameStatePlayers.filter((p) => p.alive);
        if (alivePlayers.length <= 2) {
          const demon = alivePlayers.find((p) => p.type === "demon");
          if (demon) {
            endGame(false);
            return;
          }
        }
      }

      function generateAndDisplayScript() {
        evilHasGrim = false;
        killModeToggleBtn.disabled = false;
        canExecutePlayer = true;
        phaseDisplay.classList.remove("good-wins", "evil-wins");

        setupCenterButton(null, null, false);
        const playerCount = parseInt(playerCountSelect.value, 10);
        let counts = { ...playerCounts[playerCount] };
        const baseOutsiderCount = counts.outsiders;

        // --- SCRIPT GENERATION ---
        // generate demon (its imp!)
        const selectedDemons = getRandomItems(
          characters.demons,
          counts.demons
        ).selected;
        // generate minions
        const selectedMinions = getRandomItems(
          characters.minions,
          counts.minions
        ).selected;
        const isBaronInPlay = selectedMinions.some(
          (minion) => minion.name === "Baron"
        );

        if (isBaronInPlay) {
          counts.townsfolk -= 2;
          counts.outsiders += 2;
        }
        const spyInPlay = selectedMinions.some(
          (minion) => minion.name === "Spy"
        );
        evilHasGrim = spyInPlay;
        // generate outsiders
        const outsiderRNG = getRandomItems(
          characters.outsiders,
          counts.outsiders
        );
        const selectedOutsiders = outsiderRNG.selected;
        const notInPlayOutsiders = outsiderRNG.notSelected;

        const townsfolkRNG = getRandomItems(
          characters.townsfolk,
          counts.townsfolk
        );
        const selectedTownsfolk = townsfolkRNG.selected;
        const notInPlayTownsfolk = townsfolkRNG.notSelected;

        const faceUpOutsiders = selectedOutsiders.filter(
          (item) => item.name !== "Drunk"
        ).length;

        // calculate correct number of outsider bluffs that can be given
        let maxOutsiderBluffs = baseOutsiderCount + 2 - faceUpOutsiders;

        const bluffableOutsiders = notInPlayOutsiders
          .filter((item) => item.name !== "Drunk")
          .slice(0, maxOutsiderBluffs);

        // if there is a drunk, pop one item from notinplaytownsfolk
        const isDrunkInPlay =
          selectedOutsiders.findIndex((o) => o.name === "Drunk") > -1;
        const designatedDrunkBluff = isDrunkInPlay
          ? notInPlayTownsfolk.pop()
          : null;

        const bluffRNG = getRandomItems(
          [...bluffableOutsiders, ...notInPlayTownsfolk],
          3
        );
        const demonBluffs = bluffRNG.selected;
        const unusedBluffs = bluffRNG.notSelected;

        if (selectedMinions.length === 3) {
          // if there is spy, you get another free bluff! yay
          if (spyInPlay) {
            demonBluffs.push(unusedBluffs[0]);
          } else {
            // otherwise you just have to randomly claim something.
            const roleToClaim = getRandomItems(
              [...characters.townsfolk, ...characters.outsiders].filter(
                (role) => role.name !== "Drunk"
              ),
              1
            ).selected[0];
            demonBluffs.push(roleToClaim);
          }
        }
        const ingamePlayers = shuffleArray(playerNames.slice(0, playerCount));

        const shuffledTokens = shuffleArray([
          ...selectedDemons,
          ...selectedMinions,
          ...selectedOutsiders,
          ...selectedTownsfolk,
        ]);

        // collect all the tokens and then turn them into players
        let demonBluffIndex = 0;
        gameStatePlayers = [];
        for (let i = 0; i < shuffledTokens.length; i++) {
          // minions/demons each get a bluff
          const token = shuffledTokens[i];
          let appears_as = { role: token.name, type: token.type };
          let gameover_text = "";
          if (token.type === "minion" || token.type === "demon") {
            appears_as = {
              role: demonBluffs[demonBluffIndex].name,
              type: demonBluffs[demonBluffIndex].type,
            };
            gameover_text = `I was the ${token.name} bluffing ${appears_as.role}`;
            demonBluffIndex++;
          }
          if (token.name === "Drunk") {
            appears_as = {
              role: designatedDrunkBluff.name,
              type: designatedDrunkBluff.type,
            };
            gameover_text = `I saw myself as ${designatedDrunkBluff.name}`;
          }
          const player = {
            seat: i,
            name: ingamePlayers[i],
            role: token.name,
            type: token.type,
            evil: token.evil,
            alive: true,
            appears_as,
            info_text: "",
            droisoned: token.name === "Drunk",
            gameover_text,
          };
          gameStatePlayers.push(player);
        }

        night1();
        phaseNumber = 1;
        updatePhaseDisplay();
        displayPlayerCircle(false);
      }

      function displayPlayerCircle(grim_reveal = false) {
        circleContainer.innerHTML = "";
        const playerCount = gameStatePlayers.length;
        console.log(gameStatePlayers); // TODO: debug mode
        const radius = circleContainer.offsetWidth / 2 - 70; // 70 is a magic number for spacing

        for (let i = 0; i < playerCount; i++) {
          const player = gameStatePlayers[i];
          const angle = (i / playerCount) * 360;
          const angleRad = angle * (Math.PI / 180);

          const x = radius * Math.cos(angleRad);
          const y = radius * Math.sin(angleRad);

          const role = grim_reveal ? player : player.appears_as;
          const playerName = player.name;

          const tokenEl = document.createElement("div");
          tokenEl.className = `player-token ${role.type} ${
            player.alive ? "" : "dead"
          }`;

          // The transform places the element around the circle. The final rotate(-angle) keeps the text upright.
          tokenEl.style.transform = `translate(${x}px, ${y}px) rotate(${angle}deg) translate(60px) rotate(-${angle}deg)`;

          let speech = "";

          if (grim_reveal) {
            speech = player.gameover_text || "";
          } else {
            speech = player.info_text || "";
          }

          tokenEl.innerHTML = `
              <div class="speech-bubble${
                speech ? " visible" : ""
              }">${speech}</div>
              <strong>${playerName}</strong>
              <span>${role.role}</span>
            `;
          // Add a click listener to toggle the 'dead' class on the token.
          // This allows you to mark players as executed.
          tokenEl.addEventListener("click", () => {
            if (isKillMode) {
              executePlayer(tokenEl, i);
            }
            // TODO: If kill mode is off, clicking does nothing. (for now)
          });

          circleContainer.appendChild(tokenEl);
        }
      }

      function endGame(goodWon) {
        isKillMode = false;
        document.body.classList.remove("kill-mode-active");
        container.classList.remove("kill-mode-active");
        killModeToggleBtn.textContent = "Execute Mode: OFF";

        killModeToggleBtn.disabled = true;

        phaseDisplay.classList.remove("good-wins", "evil-wins");
        phaseDisplay.textContent = goodWon ? "GOOD WIN" : "EVIL WIN";
        phaseDisplay.classList.add(goodWon ? "good-wins" : "evil-wins");

        setupCenterButton(null, null, false);

        canExecutePlayer = false;

        displayPlayerCircle(true); // grim reveal
      }

      // ----- GOOD for some nice RNG  ----
      // function main() {
      //   for (let i = 0; i < 40000; i++) {
      //     generateAndDisplayScript();
      //     x[
      //       countEvilPairs(gameStatePlayers, flipCoin(), flipCoin())
      //     ]++;
      //   }
      //   console.log(x);
      // }

      document.addEventListener("DOMContentLoaded", generateAndDisplayScript);
      generateBtn.addEventListener("click", generateAndDisplayScript);
      centerActionButton.addEventListener("click", () => {
        if (typeof currentCenterAction === "function") {
          currentCenterAction(); // Execute the stored function
        }
      });
    </script>
  </body>
</html>
